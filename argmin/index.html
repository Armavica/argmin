<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `argmin` crate."><meta name="keywords" content="rust, rustlang, rust-lang, argmin"><title>argmin - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="shortcut icon" href="../favicon.ico"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='..//index.html'><img src='../rust-logo.png' alt='logo' width='100'></a><p class='location'>Crate argmin</p><div class="sidebar-elems"><a id='all-types' href='all.html'><p>See all argmin's items</p></a><div class="block items"><ul><li><a href="#modules">Modules</a></li></ul></div><p class='location'></p><script>window.sidebarCurrent = {name: 'argmin', ty: 'mod', relpath: '../'};</script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/argmin/lib.rs.html#8-413' title='goto source code'>[src]</a></span><span class='in-band'>Crate <a class="mod" href=''>argmin</a></span></h1><div class='docblock'><p>A pure Rust optimization framework</p>
<p>This crate offers a (work in progress) numerical optimization toolbox/framework written entirely
in Rust. It is at the moment quite unstable and potentially very buggy. Please use with care and
report any bugs you encounter. This crate is looking for contributors!</p>
<h1 id="design-goals" class="section-header"><a href="#design-goals">Design goals</a></h1>
<p>This crate's intention is to be useful to users as well as developers of optimization
algorithms, meaning that it should be both easy to apply and easy to implement algorithms. In
particular, as a developer of optimization algorithms you should not need to worry about
usability features (such as logging, dealing with different types, setters and getters for
certain common parameters, counting cost function and gradient evaluations, termination, and so
on). Instead you can focus on implementing your algorithm and let <code>argmin-codegen</code> do the rest.</p>
<ul>
<li>Easy framework for the implementation of optimization algorithms: Define a struct to hold your
data, implement a single iteration of your method and let argmin generate the rest with
<code>#[derive(ArgminSolver)]</code>. This lead to similar interfaces for different solvers, making it
easy for users.</li>
<li>Pure Rust implementations of a wide range of optimization methods: This avoids the need to
compile and interface C/C++/Fortran code.</li>
<li>Type-agnostic: Many problems require data structures that go beyond simple vectors to
represent the parameters. In argmin, everything is generic: All that needs to be done is
implementing certain traits on your data type. For common types, these traits are already
implemented.</li>
<li>Convenient: Automatic and consistent logging of anything that may be important. Log to the
terminal, to a file or implement your own loggers. Future plans include sending metrics to
databases and connecting to big data piplines.</li>
<li>Algorithm evaluation: Methods to assess the performance of an algorithm for different
parameter settings, problem classes, ...</li>
</ul>
<p>Since this crate is in a very early stage, so far most points are only partially implemented or
remain future plans.</p>
<h1 id="algorithms" class="section-header"><a href="#algorithms">Algorithms</a></h1>
<ul>
<li><a href="solver/linesearch/index.html">Line searches</a>
<ul>
<li><a href="solver/linesearch/backtracking/struct.BacktrackingLineSearch.html">Backtracking line search</a></li>
<li><a href="solver/linesearch/morethuente/struct.MoreThuenteLineSearch.html">More-Thuente line search</a></li>
<li><a href="solver/linesearch/hagerzhang/struct.HagerZhangLineSearch.html">Hager-Zhang line search</a></li>
</ul>
</li>
<li><a href="solver/trustregion/trustregion_method/struct.TrustRegion.html">Trust region method</a>
<ul>
<li><a href="solver/trustregion/cauchypoint/struct.CauchyPoint.html">Cauchy point method</a></li>
<li><a href="solver/trustregion/dogleg/struct.Dogleg.html">Dogleg method</a></li>
<li><a href="solver/trustregion/steihaug/struct.Steihaug.html">Steihaug method</a></li>
</ul>
</li>
<li><a href="solver/gradientdescent/steepestdescent/struct.SteepestDescent.html">Steepest descent</a></li>
<li><a href="solver/conjugategradient/cg/struct.ConjugateGradient.html">Conjugate gradient method</a></li>
<li><a href="solver/conjugategradient/nonlinear_cg/struct.NonlinearConjugateGradient.html">Nonlinear conjugate gradient method</a></li>
<li><a href="solver/newton/index.html">Newton methods</a>
<ul>
<li><a href="solver/newton/newton_method/struct.Newton.html">Newton's method</a></li>
<li><a href="solver/newton/newton_cg/struct.NewtonCG.html">Newton-CG</a></li>
</ul>
</li>
<li><a href="solver/quasinewton/index.html">Quasi-Newton methods</a>
<ul>
<li><a href="solver/quasinewton/bfgs/struct.BFGS.html">BFGS</a></li>
</ul>
</li>
<li><a href="solver/landweber/struct.Landweber.html">Landweber iteration</a></li>
<li><a href="solver/simulatedannealing/struct.SimulatedAnnealing.html">Simulated Annealing</a></li>
</ul>
<h1 id="usage" class="section-header"><a href="#usage">Usage</a></h1>
<p>Add this to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
argmin = &quot;0.1.7&quot;
</code></pre>
<h2 id="optional-features" class="section-header"><a href="#optional-features">Optional features</a></h2>
<p>There are additional features which can be activated in <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
argmin = { version = &quot;0.1.7&quot;, features = [&quot;ctrlc&quot;, &quot;ndarrayl&quot;] }
</code></pre>
<p>These may become default features in the future. Without these features compilation to
<code>wasm32-unknown-unkown</code> seems to be possible.</p>
<ul>
<li><code>ctrlc</code>: Uses the <code>ctrlc</code> crate to properly stop the optimization (and return the current best
result) after pressing Ctrl+C.</li>
<li><code>ndarrayl</code>: Support for <code>ndarray</code> and <code>ndarray-linalg</code>.</li>
</ul>
<h1 id="defining-a-problem" class="section-header"><a href="#defining-a-problem">Defining a problem</a></h1>
<p>A problem can be defined by implementing the <code>ArgminOp</code> trait which comes with the
associated types <code>Param</code>, <code>Output</code> and <code>Hessian</code>. <code>Param</code> is the type of your
parameter vector (i.e. the input to your cost function), <code>Output</code> is the type returned
by the cost function and <code>Hessian</code> is the type of the Hessian.
The trait provides the following methods:</p>
<ul>
<li><code>apply(&amp;self, p: &amp;Self::Param) -&gt; Result&lt;Self::Output, Error&gt;</code>: Applys the cost
function to parameters <code>p</code> of type <code>Self::Param</code> and returns the cost function value.</li>
<li><code>gradient(&amp;self, p: &amp;Self::Param) -&gt; Result&lt;Self::Param, Error&gt;</code>: Computes the
gradient at <code>p</code>. Optional. By default returns an <code>Err</code> if not implemented.</li>
<li><code>hessian(&amp;self, p: &amp;Self::Param) -&gt; Result&lt;Self::Hessian, Error&gt;</code>: Computes the Hessian
at <code>p</code>. Optional. By default returns an <code>Err</code> if not implemented. The type of <code>Hessian</code> can
be set to <code>()</code> if this method is not implemented.</li>
</ul>
<p>The following code snippet shows an example of how to use the Rosenbrock test functions from
<code>argmin-testfunctions</code> in argmin:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// [Imports omited]</span>

<span class="doccomment">/// First, create a struct for your problem</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Clone</span>, <span class="ident">Default</span>, <span class="ident">Serialize</span>, <span class="ident">Deserialize</span>)]</span>
<span class="kw">struct</span> <span class="ident">Rosenbrock</span> {
    <span class="ident">a</span>: <span class="ident">f64</span>,
    <span class="ident">b</span>: <span class="ident">f64</span>,
}

<span class="doccomment">/// Implement `ArgminOp` for `Rosenbrock`</span>
<span class="kw">impl</span> <span class="ident">ArgminOp</span> <span class="kw">for</span> <span class="ident">Rosenbrock</span> {
    <span class="doccomment">/// Type of the parameter vector</span>
    <span class="kw">type</span> <span class="ident">Param</span> <span class="op">=</span> <span class="ident">ndarray</span>::<span class="ident">Array1</span><span class="op">&lt;</span><span class="ident">f64</span><span class="op">&gt;</span>;
    <span class="doccomment">/// Type of the return value computed by the cost function</span>
    <span class="kw">type</span> <span class="ident">Output</span> <span class="op">=</span> <span class="ident">f64</span>;
    <span class="doccomment">/// Type of the Hessian. If no Hessian is available or needed for the used solver, this can</span>
    <span class="doccomment">/// be set to `()`</span>
    <span class="kw">type</span> <span class="ident">Hessian</span> <span class="op">=</span> <span class="ident">ndarray</span>::<span class="ident">Array2</span><span class="op">&lt;</span><span class="ident">f64</span><span class="op">&gt;</span>;

    <span class="doccomment">/// Apply the cost function to a parameter `p`</span>
    <span class="kw">fn</span> <span class="ident">apply</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">p</span>: <span class="kw-2">&amp;</span><span class="self">Self</span>::<span class="ident">Param</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="self">Self</span>::<span class="ident">Output</span>, <span class="ident">Error</span><span class="op">&gt;</span> {
        <span class="prelude-val">Ok</span>(<span class="ident">rosenbrock_2d</span>(<span class="kw-2">&amp;</span><span class="ident">p</span>.<span class="ident">to_vec</span>(), <span class="self">self</span>.<span class="ident">a</span>, <span class="self">self</span>.<span class="ident">b</span>))
    }

    <span class="doccomment">/// Compute the gradient at parameter `p`. This is optional: If not implemented, this</span>
    <span class="doccomment">/// method will return an `Err` when called.</span>
    <span class="kw">fn</span> <span class="ident">gradient</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">p</span>: <span class="kw-2">&amp;</span><span class="self">Self</span>::<span class="ident">Param</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="self">Self</span>::<span class="ident">Param</span>, <span class="ident">Error</span><span class="op">&gt;</span> {
        <span class="prelude-val">Ok</span>(<span class="ident">ndarray</span>::<span class="ident">Array1</span>::<span class="ident">from_vec</span>(<span class="ident">rosenbrock_2d_derivative</span>(<span class="kw-2">&amp;</span><span class="ident">p</span>.<span class="ident">to_vec</span>(), <span class="self">self</span>.<span class="ident">a</span>, <span class="self">self</span>.<span class="ident">b</span>)))
    }

    <span class="doccomment">/// Compute the Hessian at parameter `p`. This is optional: If not implemented, this method</span>
    <span class="doccomment">/// will return an `Err` when called.</span>
    <span class="kw">fn</span> <span class="ident">hessian</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">p</span>: <span class="kw-2">&amp;</span><span class="self">Self</span>::<span class="ident">Param</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="self">Self</span>::<span class="ident">Hessian</span>, <span class="ident">Error</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="ident">h</span> <span class="op">=</span> <span class="ident">rosenbrock_2d_hessian</span>(<span class="kw-2">&amp;</span><span class="ident">p</span>.<span class="ident">to_vec</span>(), <span class="self">self</span>.<span class="ident">a</span>, <span class="self">self</span>.<span class="ident">b</span>);
        <span class="prelude-val">Ok</span>(<span class="ident">ndarray</span>::<span class="ident">Array</span>::<span class="ident">from_shape_vec</span>((<span class="number">2</span>, <span class="number">2</span>), <span class="ident">h</span>).<span class="ident">unwrap</span>())
    }
}</pre></div>
<h1 id="running-a-solver" class="section-header"><a href="#running-a-solver">Running a solver</a></h1>
<p>The following example shows how to use the previously shown definition of a problem in a
Steepest Descent (Gradient Descent) solver.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">argmin</span>;
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">ndarray</span>;
<span class="kw">use</span> <span class="ident">argmin</span>::<span class="ident">testfunctions</span>::{<span class="ident">rosenbrock_2d</span>, <span class="ident">rosenbrock_2d_derivative</span>, <span class="ident">rosenbrock_2d_hessian</span>};
<span class="kw">use</span> <span class="ident">argmin</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">argmin</span>::<span class="ident">solver</span>::<span class="ident">gradientdescent</span>::<span class="ident">SteepestDescent</span>;
<span class="kw">use</span> <span class="ident">argmin</span>::<span class="ident">solver</span>::<span class="ident">linesearch</span>::<span class="ident">MoreThuenteLineSearch</span>;
<span class="kw">use</span> <span class="ident">serde</span>::{<span class="ident">Serialize</span>, <span class="ident">Deserialize</span>};

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Clone</span>, <span class="ident">Default</span>, <span class="ident">Serialize</span>, <span class="ident">Deserialize</span>)]</span>
<span class="kw">struct</span> <span class="ident">Rosenbrock</span> {
    <span class="ident">a</span>: <span class="ident">f64</span>,
    <span class="ident">b</span>: <span class="ident">f64</span>,
}

<span class="kw">impl</span> <span class="ident">ArgminOp</span> <span class="kw">for</span> <span class="ident">Rosenbrock</span> {
    <span class="kw">type</span> <span class="ident">Param</span> <span class="op">=</span> <span class="ident">ndarray</span>::<span class="ident">Array1</span><span class="op">&lt;</span><span class="ident">f64</span><span class="op">&gt;</span>;
    <span class="kw">type</span> <span class="ident">Output</span> <span class="op">=</span> <span class="ident">f64</span>;
    <span class="kw">type</span> <span class="ident">Hessian</span> <span class="op">=</span> ();

   <span class="kw">fn</span> <span class="ident">apply</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">p</span>: <span class="kw-2">&amp;</span><span class="self">Self</span>::<span class="ident">Param</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="self">Self</span>::<span class="ident">Output</span>, <span class="ident">Error</span><span class="op">&gt;</span> {
       <span class="prelude-val">Ok</span>(<span class="ident">rosenbrock_2d</span>(<span class="kw-2">&amp;</span><span class="ident">p</span>.<span class="ident">to_vec</span>(), <span class="self">self</span>.<span class="ident">a</span>, <span class="self">self</span>.<span class="ident">b</span>))
   }

   <span class="kw">fn</span> <span class="ident">gradient</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">p</span>: <span class="kw-2">&amp;</span><span class="self">Self</span>::<span class="ident">Param</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="self">Self</span>::<span class="ident">Param</span>, <span class="ident">Error</span><span class="op">&gt;</span> {
       <span class="prelude-val">Ok</span>(<span class="ident">ndarray</span>::<span class="ident">Array1</span>::<span class="ident">from_vec</span>(<span class="ident">rosenbrock_2d_derivative</span>(<span class="kw-2">&amp;</span><span class="ident">p</span>.<span class="ident">to_vec</span>(), <span class="self">self</span>.<span class="ident">a</span>, <span class="self">self</span>.<span class="ident">b</span>)))
   }
}

<span class="kw">fn</span> <span class="ident">run</span>() <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Error</span><span class="op">&gt;</span> {
    <span class="comment">// Define cost function</span>
    <span class="kw">let</span> <span class="ident">cost</span> <span class="op">=</span> <span class="ident">Rosenbrock</span> { <span class="ident">a</span>: <span class="number">1.0</span>, <span class="ident">b</span>: <span class="number">100.0</span> };

    <span class="comment">// Define inital parameter vector</span>
    <span class="kw">let</span> <span class="ident">init_param</span> <span class="op">=</span> <span class="ident">ndarray</span>::<span class="ident">Array1</span>::<span class="ident">from_vec</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="op">-</span><span class="number">1.2</span>, <span class="number">1.0</span>]);

    <span class="comment">// Pick a line search.</span>
    <span class="comment">// let linesearch = HagerZhangLineSearch::new(cost.clone());</span>
    <span class="kw">let</span> <span class="ident">linesearch</span> <span class="op">=</span> <span class="ident">MoreThuenteLineSearch</span>::<span class="ident">new</span>(<span class="ident">cost</span>.<span class="ident">clone</span>());
    <span class="comment">// let linesearch = BacktrackingLineSearch::new(cost.clone());</span>

    <span class="comment">// Create solver</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">solver</span> <span class="op">=</span> <span class="ident">SteepestDescent</span>::<span class="ident">new</span>(<span class="ident">cost</span>, <span class="ident">init_param</span>, <span class="ident">linesearch</span>)<span class="question-mark">?</span>;

    <span class="comment">// Set the maximum number of iterations to 1000</span>
    <span class="ident">solver</span>.<span class="ident">set_max_iters</span>(<span class="number">1000</span>);

    <span class="comment">// Attach a terminal logger (slog) to the solver</span>
    <span class="ident">solver</span>.<span class="ident">add_logger</span>(<span class="ident">ArgminSlogLogger</span>::<span class="ident">term</span>());

    <span class="comment">// Run the solver</span>
    <span class="ident">solver</span>.<span class="ident">run</span>()<span class="question-mark">?</span>;

    <span class="comment">// Print the result</span>
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">solver</span>.<span class="ident">result</span>());
    <span class="prelude-val">Ok</span>(())
}

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Err</span>(<span class="kw-2">ref</span> <span class="ident">e</span>) <span class="op">=</span> <span class="ident">run</span>() {
        <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{} {}&quot;</span>, <span class="ident">e</span>.<span class="ident">as_fail</span>(), <span class="ident">e</span>.<span class="ident">backtrace</span>());
        <span class="ident">std</span>::<span class="ident">process</span>::<span class="ident">exit</span>(<span class="number">1</span>);
    }
}</pre></div>
<p>Executing <code>solver.run()?</code> performs the actual optimization. In addition, there is
<code>solver.run_fast()?</code>, which only executes the optimization algorithm and avoids all convenience
functionality such as logging.</p>
<h1 id="logging" class="section-header"><a href="#logging">Logging</a></h1>
<p>Information such as the current iteration number, cost function value, and other metrics can be
logged using any object which implements <code>argmin_core::ArgminLogger</code>. So far loggers based on
the <code>slog</code> crate have been implemented: <code>ArgminSlogLogger::term</code> logs to the terminal and
<code>ArgminSlogLogger::file</code> logs to a file in JSON format. Both loggers come with a <code>*_noblock</code>
version which does not block the execution for logging, but may drop log entries when the
buffer fills up.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">solver</span> <span class="op">=</span> <span class="ident">SteepestDescent</span>::<span class="ident">new</span>(<span class="ident">cost</span>, <span class="ident">init_param</span>, <span class="ident">linesearch</span>)<span class="question-mark">?</span>;
<span class="comment">// Log to the terminal</span>
<span class="ident">solver</span>.<span class="ident">add_logger</span>(<span class="ident">ArgminSlogLogger</span>::<span class="ident">term</span>());
<span class="comment">// Log to the terminal without blocking</span>
<span class="ident">solver</span>.<span class="ident">add_logger</span>(<span class="ident">ArgminSlogLogger</span>::<span class="ident">term_noblock</span>());
<span class="comment">// Log to the file `log1.log`</span>
<span class="ident">solver</span>.<span class="ident">add_logger</span>(<span class="ident">ArgminSlogLogger</span>::<span class="ident">file</span>(<span class="string">&quot;log1.log&quot;</span>)<span class="question-mark">?</span>);
<span class="comment">// Log to the file `log2.log` without blocking</span>
<span class="ident">solver</span>.<span class="ident">add_logger</span>(<span class="ident">ArgminSlogLogger</span>::<span class="ident">file_noblock</span>(<span class="string">&quot;log2.log&quot;</span>)<span class="question-mark">?</span>);</pre></div>
<h1 id="implementing-an-optimization-algorithm" class="section-header"><a href="#implementing-an-optimization-algorithm">Implementing an optimization algorithm</a></h1>
<p>In this section we are going to implement the Landweber solver, which essentially is a special
form of gradient descent. In iteration <code>k</code>, the new parameter vector <code>x_{k+1}</code> is calculated
from the previous parameter vector <code>x_k</code> and the gradient at <code>x_k</code> according to the following
update rule:</p>
<p><code>x_{k+1} = x_k - omega * \nabla f(x_k)</code></p>
<p>In order to implement this using the argmin framework, one first needs to define a struct which
holds data/parameters needed during the execution of the algorithm. In addition a field with
the name <code>base</code> and type <code>ArgminBase&lt;'a, T, U, H&gt;</code> is needed, where <code>T</code> is the type of the
parameter vector, <code>U</code> is the type of the return values of the cost function and <code>H</code> is the type
of the Hessian (which can be <code>()</code> if not available).</p>
<p>Deriving <code>ArgminSolver</code> for the struct using <code>#[derive(ArgminSolver)]</code> implements most of the
API. What remains to be implemented for the struct is a constructor and <code>ArgminNextIter</code>. The
latter is essentially an implementation of a single iteration of the algorithm.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// needed for `#[derive(ArgminSolver)]`</span>
<span class="kw">use</span> <span class="ident">argmin_codegen</span>::<span class="ident">ArgminSolver</span>;
<span class="kw">use</span> <span class="ident">argmin</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">default</span>::<span class="ident">Default</span>;
<span class="kw">use</span> <span class="ident">serde</span>::{<span class="ident">Serialize</span>, <span class="ident">Deserialize</span>};

<span class="comment">// The `Landweber` struct holds the `omega` parameter and has a field `base` which is of type</span>
<span class="comment">// `ArgminBase`. The struct is generic over the ArgminOp `O` which holds type information about</span>
<span class="comment">// the parameter vector which (in this particular case) has to implement</span>
<span class="comment">// `ArgminScaledSub&lt;T, f64&gt;`, which is neede for the update rule.</span>
<span class="comment">// Deriving `ArgminSolver` implements a large portion of the API and provides many convenience</span>
<span class="comment">// functions. It requires that `ArgminIter` is implemented on `Landweber` as well.</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">ArgminSolver</span>, <span class="ident">Serialize</span>, <span class="ident">Deserialize</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Landweber</span><span class="op">&lt;</span><span class="ident">O</span><span class="op">&gt;</span>
<span class="kw">where</span>
    <span class="ident">O</span>::<span class="ident">Param</span>: <span class="ident">ArgminScaledSub</span><span class="op">&lt;</span><span class="ident">O</span>::<span class="ident">Param</span>, <span class="ident">f64</span>, <span class="ident">O</span>::<span class="ident">Param</span><span class="op">&gt;</span>,
    <span class="ident">O</span>: <span class="ident">ArgminOp</span>,
{
    <span class="ident">omega</span>: <span class="ident">f64</span>,
    <span class="ident">base</span>: <span class="ident">ArgminBase</span><span class="op">&lt;</span><span class="ident">O</span><span class="op">&gt;</span>,
}

<span class="comment">// For convenience, a constructor can/should be implemented</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">O</span><span class="op">&gt;</span> <span class="ident">Landweber</span><span class="op">&lt;</span><span class="ident">O</span><span class="op">&gt;</span>
<span class="kw">where</span>
    <span class="ident">O</span>::<span class="ident">Param</span>: <span class="ident">ArgminScaledSub</span><span class="op">&lt;</span><span class="ident">O</span>::<span class="ident">Param</span>, <span class="ident">f64</span>, <span class="ident">O</span>::<span class="ident">Param</span><span class="op">&gt;</span>,
    <span class="ident">O</span>: <span class="ident">ArgminOp</span>,
{
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">new</span>(
        <span class="ident">cost_function</span>: <span class="ident">O</span>,
        <span class="ident">omega</span>: <span class="ident">f64</span>,
        <span class="ident">init_param</span>: <span class="ident">O</span>::<span class="ident">Param</span>,
    ) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="self">Self</span>, <span class="ident">Error</span><span class="op">&gt;</span> {
        <span class="prelude-val">Ok</span>(<span class="ident">Landweber</span> {
            <span class="ident">omega</span>,
            <span class="ident">base</span>: <span class="ident">ArgminBase</span>::<span class="ident">new</span>(<span class="ident">cost_function</span>, <span class="ident">init_param</span>),
        })
    }
}

<span class="comment">// This implements a single iteration of the optimization algorithm.</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">O</span><span class="op">&gt;</span> <span class="ident">ArgminIter</span> <span class="kw">for</span> <span class="ident">Landweber</span><span class="op">&lt;</span><span class="ident">O</span><span class="op">&gt;</span>
<span class="kw">where</span>
    <span class="ident">O</span>::<span class="ident">Param</span>: <span class="ident">ArgminScaledSub</span><span class="op">&lt;</span><span class="ident">O</span>::<span class="ident">Param</span>, <span class="ident">f64</span>, <span class="ident">O</span>::<span class="ident">Param</span><span class="op">&gt;</span>,
    <span class="ident">O</span>: <span class="ident">ArgminOp</span>,
{
    <span class="kw">type</span> <span class="ident">Param</span> <span class="op">=</span> <span class="ident">O</span>::<span class="ident">Param</span>;
    <span class="kw">type</span> <span class="ident">Output</span> <span class="op">=</span> <span class="ident">O</span>::<span class="ident">Output</span>;
    <span class="kw">type</span> <span class="ident">Hessian</span> <span class="op">=</span> <span class="ident">O</span>::<span class="ident">Hessian</span>;

    <span class="kw">fn</span> <span class="ident">next_iter</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">ArgminIterData</span><span class="op">&lt;</span><span class="self">Self</span>::<span class="ident">Param</span><span class="op">&gt;</span>, <span class="ident">Error</span><span class="op">&gt;</span> {
        <span class="comment">// Obtain current parameter vector</span>
        <span class="comment">// The method `cur_param()` has been implemented by deriving `ArgminSolver`.</span>
        <span class="kw">let</span> <span class="ident">param</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">cur_param</span>();
        <span class="comment">// Compute gradient at current parameter vector `param`</span>
        <span class="comment">// The method `gradient()` has been implemented by deriving `ArgminSolver`.</span>
        <span class="kw">let</span> <span class="ident">grad</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">gradient</span>(<span class="kw-2">&amp;</span><span class="ident">param</span>)<span class="question-mark">?</span>;
        <span class="comment">// Calculate new parameter vector based on update rule</span>
        <span class="kw">let</span> <span class="ident">new_param</span> <span class="op">=</span> <span class="ident">param</span>.<span class="ident">scaled_sub</span>(<span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">omega</span>, <span class="kw-2">&amp;</span><span class="ident">grad</span>);
        <span class="comment">// Return new parameter vector. Since there is no need to compute the cost function</span>
        <span class="comment">// value, we return 0.0 instead.</span>
        <span class="kw">let</span> <span class="ident">out</span> <span class="op">=</span> <span class="ident">ArgminIterData</span>::<span class="ident">new</span>(<span class="ident">new_param</span>, <span class="number">0.0</span>);
        <span class="prelude-val">Ok</span>(<span class="ident">out</span>)
    }
}</pre></div>
</div><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table><tr class='module-item'><td><a class="mod" href="prelude/index.html" title='argmin::prelude mod'>prelude</a></td><td class='docblock-short'><p>Definition of all relevant traits and types</p>
</td></tr><tr class='module-item'><td><a class="mod" href="solver/index.html" title='argmin::solver mod'>solver</a></td><td class='docblock-short'><p>Solvers</p>
</td></tr><tr class='module-item'><td><a class="mod" href="testfunctions/index.html" title='argmin::testfunctions mod'>testfunctions</a></td><td class='docblock-short'><p>Testfunctions</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g., <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g., <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g., <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../";window.currentCrate = "argmin";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>
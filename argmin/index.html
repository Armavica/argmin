<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `argmin` crate."><meta name="keywords" content="rust, rustlang, rust-lang, argmin"><title>argmin - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><p class='location'>Crate argmin</p><div class="sidebar-elems"><a id='all-types' href='all.html'><p>See all argmin's items</p></a><div class="block items"><ul><li><a href="#modules">Modules</a></li></ul></div><p class='location'></p><script>window.sidebarCurrent = {name: 'argmin', ty: 'mod', relpath: '../'};</script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/argmin/lib.rs.html#8-260' title='goto source code'>[src]</a></span><span class='in-band'>Crate <a class="mod" href=''>argmin</a></span></h1><div class='docblock'><p>A pure Rust optimization framework</p>
<p>This crate offers a (work in progress) numerical optimization toolbox/framework written entirely
in Rust. It is at the moment quite unstable and potentially very buggy. Please use with care and
report any bugs you encounter. This crate is looking for contributors!</p>
<h1 id="design-goals" class="section-header"><a href="#design-goals">Design goals</a></h1>
<p>This crate's intention is to be useful to users as well as developers of optimization
algorithms, meaning that it should be both easy to apply and easy to implement algorithms. In
particular, as a developer of optimization algorithms you should not need to worry about
usability features (such as logging, dealing with different types, setters and getters for
certain common parameters, counting cost function and gradient evaluations, termination, and so
on). Instead you can focus on implementing your algorithm and let <code>argmin-codegen</code> do the rest.</p>
<ul>
<li>Easy framework for the implementation of optimization algorithms: Define a struct to hold your
data, implement a single iteration of your method and let argmin generate the rest with
<code>#[derive(ArgminSolver)]</code>. This lead to similar interfaces for different solvers, making it
easy for users.</li>
<li>Pure Rust implementations of a wide range of optimization methods: This avoids the need to
compile and interface C/C++/Fortran code.</li>
<li>Type-agnostic: Many problems require data structures that go beyond simple vectors to
represent the parameters. In argmin, everything is generic: All that needs to be done is
implementing certain traits on your data type. For common types, these traits are already
implemented.</li>
<li>Convenient: Automatic and consistent logging of anything that may be important. Log to the
terminal, to a file or implement your own loggers. Future plans include sending metrics to
databases and connecting to big data piplines.</li>
<li>Algorithm evaluation: Methods to assess the performance of an algorithm for different
parameter settings, problem classes, ...</li>
</ul>
<p>Since this crate is in a very early stage, so far most points are only partially implemented or
remain future plans.</p>
<h1 id="algorithms" class="section-header"><a href="#algorithms">Algorithms</a></h1>
<ul>
<li>Linesearches
<ul>
<li>Backtracking line search</li>
<li>More-Thuente line search</li>
<li>Hager-Zhang line search</li>
</ul>
</li>
<li>Trust region method
<ul>
<li>Cauchy point method</li>
<li>Dogleg method</li>
<li>Steihaug method</li>
</ul>
</li>
<li>Steepest Descent</li>
<li>Conjugate Gradient method</li>
<li>Nonlinear Conjugate Gradient method</li>
<li>Newton Methods
<ul>
<li>Basic Newton's Method</li>
<li>Newton-CG</li>
</ul>
</li>
<li>Landweber iteration</li>
<li>Simulated Annealing</li>
</ul>
<h1 id="usage" class="section-header"><a href="#usage">Usage</a></h1>
<p>Add this to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
argmin = &quot;0.1.5&quot;
</code></pre>
<h2 id="optional-features" class="section-header"><a href="#optional-features">Optional features</a></h2>
<p>There are additional features which can be activated in <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
argmin = { version = &quot;0.1.5&quot;, features = [&quot;ctrlc&quot;, &quot;ndarrayl&quot;] }
</code></pre>
<p>These may become default features in the future. Without these features compilation to
<code>wasm32-unknown-unkown</code> seems to be possible.</p>
<ul>
<li><code>ctrlc</code>: Uses the <code>ctrlc</code> crate to properly stop the optimization (and return the current best
result) after pressing Ctrl+C.</li>
<li><code>ndarrayl</code>: Support for <code>ndarray</code> and <code>ndarray-linalg</code>.</li>
</ul>
<h1 id="defining-a-problem" class="section-header"><a href="#defining-a-problem">Defining a problem</a></h1>
<p>A problem can be defined by implementing the <code>ArgminOperator</code> trait which comes with the
associated types <code>Parameters</code>, <code>OperatorOutput</code> and <code>Hessian</code>. <code>Parameters</code> is the type of your
parameter vector (i.e. the input to your cost function), <code>OperatorOutput</code> is the type returned
by the cost function and <code>Hessian</code> is the type of the Hessian.
The trait provides the following methods:</p>
<ul>
<li><code>apply(&amp;self, p: &amp;Self::Parameters) -&gt; Result&lt;Self::OperatorOutput, Error&gt;</code>: Applys the cost
function to parameters <code>p</code> of type <code>Self::Parameters</code> and returns the cost function value.</li>
<li><code>gradient(&amp;self, p: &amp;Self::Parameters) -&gt; Result&lt;Self::Parameters, Error&gt;</code>: Computes the
gradient at <code>p</code>. Optional. By default returns an <code>Err</code> if not implemented.</li>
<li><code>hessian(&amp;self, p: &amp;Self::Parameters) -&gt; Result&lt;Self::Hessian, Error&gt;</code>: Computes the Hessian
at <code>p</code>. Optional. By default returns an <code>Err</code> if not implemented. The type of <code>Hessian</code> can
be set to <code>()</code> if this method is not implemented.</li>
</ul>
<p>The following code snippet shows an example of how to use the Rosenbrock test functions from
<code>argmin-testfunctions</code> in argmin:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// [Imports ommited]</span>

<span class="doccomment">/// First, create a struct for your problem</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Clone</span>)]</span>
<span class="kw">struct</span> <span class="ident">Rosenbrock</span> {
    <span class="ident">a</span>: <span class="ident">f64</span>,
    <span class="ident">b</span>: <span class="ident">f64</span>,
}

<span class="doccomment">/// Implement `ArgminOperator` for `Rosenbrock`</span>
<span class="kw">impl</span> <span class="ident">ArgminOperator</span> <span class="kw">for</span> <span class="ident">Rosenbrock</span> {
    <span class="doccomment">/// Type of the parameter vector</span>
    <span class="kw">type</span> <span class="ident">Parameters</span> <span class="op">=</span> <span class="ident">Array1</span><span class="op">&lt;</span><span class="ident">f64</span><span class="op">&gt;</span>;
    <span class="doccomment">/// Type of the return value computed by the cost function</span>
    <span class="kw">type</span> <span class="ident">OperatorOutput</span> <span class="op">=</span> <span class="ident">f64</span>;
    <span class="doccomment">/// Type of the Hessian. If not Hessian is available/needed, this can be set to `()`</span>
    <span class="kw">type</span> <span class="ident">Hessian</span> <span class="op">=</span> <span class="ident">Array2</span><span class="op">&lt;</span><span class="ident">f64</span><span class="op">&gt;</span>;

    <span class="doccomment">/// Apply the cost function to a parameter `p`</span>
    <span class="kw">fn</span> <span class="ident">apply</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">p</span>: <span class="kw-2">&amp;</span><span class="self">Self</span>::<span class="ident">Parameters</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="self">Self</span>::<span class="ident">OperatorOutput</span>, <span class="ident">Error</span><span class="op">&gt;</span> {
        <span class="prelude-val">Ok</span>(<span class="ident">rosenbrock_2d</span>(<span class="kw-2">&amp;</span><span class="ident">p</span>.<span class="ident">to_vec</span>(), <span class="self">self</span>.<span class="ident">a</span>, <span class="self">self</span>.<span class="ident">b</span>))
    }

    <span class="doccomment">/// Compute the gradient at parameter `p`. This is optional: If not implemented, this</span>
    <span class="doccomment">/// method will return an `Err` when called.</span>
    <span class="kw">fn</span> <span class="ident">gradient</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">p</span>: <span class="kw-2">&amp;</span><span class="self">Self</span>::<span class="ident">Parameters</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="self">Self</span>::<span class="ident">Parameters</span>, <span class="ident">Error</span><span class="op">&gt;</span> {
        <span class="prelude-val">Ok</span>(<span class="ident">Array1</span>::<span class="ident">from_vec</span>(<span class="ident">rosenbrock_2d_derivative</span>(<span class="kw-2">&amp;</span><span class="ident">p</span>.<span class="ident">to_vec</span>(), <span class="self">self</span>.<span class="ident">a</span>, <span class="self">self</span>.<span class="ident">b</span>)))
    }

    <span class="doccomment">/// Compute the Hessian at parameter `p`. This is optional: If not implemented, this method</span>
    <span class="doccomment">/// will return an `Err` when called.</span>
    <span class="kw">fn</span> <span class="ident">hessian</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">p</span>: <span class="kw-2">&amp;</span><span class="self">Self</span>::<span class="ident">Parameters</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="self">Self</span>::<span class="ident">Hessian</span>, <span class="ident">Error</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="ident">h</span> <span class="op">=</span> <span class="ident">rosenbrock_2d_hessian</span>(<span class="kw-2">&amp;</span><span class="ident">p</span>.<span class="ident">to_vec</span>(), <span class="self">self</span>.<span class="ident">a</span>, <span class="self">self</span>.<span class="ident">b</span>);
        <span class="prelude-val">Ok</span>(<span class="ident">Array</span>::<span class="ident">from_shape_vec</span>((<span class="number">2</span>, <span class="number">2</span>), <span class="ident">h</span>).<span class="ident">unwrap</span>())
    }
}
</pre></div>
<h1 id="running-a-solver" class="section-header"><a href="#running-a-solver">Running a solver</a></h1>
<p>The following example shows how to use the previously shown definition of a problem in a
Steepest Descent (Gradient Descent) solver.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">argmin</span>;
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">ndarray</span>;
<span class="kw">use</span> <span class="ident">argmin</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">argmin</span>::<span class="ident">solver</span>::<span class="ident">gradientdescent</span>::<span class="kw-2">*</span>;

<span class="comment">// [Problem definition ommited]</span>

<span class="kw">fn</span> <span class="ident">run</span>() <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Error</span><span class="op">&gt;</span> {
    <span class="comment">// Define cost function</span>
    <span class="kw">let</span> <span class="ident">cost</span> <span class="op">=</span> <span class="ident">Rosenbrock</span> { <span class="ident">a</span>: <span class="number">1.0</span>, <span class="ident">b</span>: <span class="number">100.0</span> };

    <span class="comment">// Define inital parameter vector</span>
    <span class="kw">let</span> <span class="ident">init_param</span> <span class="op">=</span> <span class="ident">ndarray</span>::<span class="ident">Array1</span>::<span class="ident">from_vec</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="op">-</span><span class="number">1.2</span>, <span class="number">1.0</span>]);

    <span class="comment">// Create solver</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">solver</span> <span class="op">=</span> <span class="ident">SteepestDescent</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">cost</span>, <span class="ident">init_param</span>)<span class="question-mark">?</span>;

    <span class="comment">// Set the maximum number of iterations to 1000</span>
    <span class="ident">solver</span>.<span class="ident">set_max_iters</span>(<span class="number">1000</span>);

    <span class="comment">// Attach a terminal logger (slog) to the solver</span>
    <span class="ident">solver</span>.<span class="ident">add_logger</span>(<span class="ident">ArgminSlogLogger</span>::<span class="ident">term</span>());

    <span class="comment">// Run the solver</span>
    <span class="ident">solver</span>.<span class="ident">run</span>()<span class="question-mark">?</span>;

    <span class="comment">// Print the result</span>
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">solver</span>.<span class="ident">result</span>());
    <span class="prelude-val">Ok</span>(())
}

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Err</span>(<span class="kw-2">ref</span> <span class="ident">e</span>) <span class="op">=</span> <span class="ident">run</span>() {
        <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{} {}&quot;</span>, <span class="ident">e</span>.<span class="ident">as_fail</span>(), <span class="ident">e</span>.<span class="ident">backtrace</span>());
        <span class="ident">std</span>::<span class="ident">process</span>::<span class="ident">exit</span>(<span class="number">1</span>);
    }
}</pre></div>
</div><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table><tr class='module-item'><td><a class="mod" href="prelude/index.html" title='argmin::prelude mod'>prelude</a></td><td class='docblock-short'><p>Definition of all relevant traits and types</p>
</td></tr><tr class='module-item'><td><a class="mod" href="solver/index.html" title='argmin::solver mod'>solver</a></td><td class='docblock-short'><p>Solvers</p>
</td></tr><tr class='module-item'><td><a class="mod" href="testfunctions/index.html" title='argmin::testfunctions mod'>testfunctions</a></td><td class='docblock-short'><p>Testfunctions</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g. <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g. <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g. <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../";window.currentCrate = "argmin";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>
var N = null;var searchIndex = {};
searchIndex["argmin"]={"doc":"A pure Rust optimization framework","items":[[0,"prelude","argmin","Definition of all relevant traits and types # Re-export of…",N,N],[0,"macros","argmin::prelude","Macros # Macros",N,N],[0,"finitediff","","Finite Differentiation",N,N],[8,"FiniteDiff","argmin::prelude::finitediff","",N,N],[16,"Jacobian","","",0,N],[16,"Hessian","","",0,N],[16,"OperatorOutput","","",0,N],[10,"forward_diff","","Forward difference calculated as",0,[[["self"],["fn"]],["self"]]],[10,"central_diff","","Central difference calculated as",0,[[["self"],["fn"]],["self"]]],[10,"forward_jacobian","","Calculation of the Jacobian J(x) of a vector function `fs`…",0,N],[10,"central_jacobian","","Calculation of the Jacobian J(x) of a vector function `fs`…",0,N],[10,"forward_jacobian_vec_prod","","Calculation of the product of the Jacobian J(x) of a…",0,[[["self"],["fn"],["self"]],["self"]]],[10,"central_jacobian_vec_prod","","Calculation of the product of the Jacobian J(x) of a…",0,[[["self"],["fn"],["self"]],["self"]]],[10,"forward_jacobian_pert","","",0,N],[10,"central_jacobian_pert","","",0,N],[10,"forward_hessian","","Calculation of the Hessian using forward differences",0,N],[10,"central_hessian","","Calculation of the Hessian using central differences",0,N],[10,"forward_hessian_vec_prod","","Calculation of the product of the Hessian H(x) of a…",0,[[["self"],["fn"],["self"]],["self"]]],[10,"central_hessian_vec_prod","","Calculation of the product of the Hessian H(x) of a…",0,[[["self"],["fn"],["self"]],["self"]]],[10,"forward_hessian_nograd","","Calculation of the Hessian using forward differences…",0,N],[10,"forward_hessian_nograd_sparse","","Calculation of a sparse Hessian using forward differences…",0,N],[3,"PerturbationVector","","Perturbation Vector for the accelerated computation of the…",N,N],[12,"x_idx","","x indices",1,N],[12,"r_idx","","correspoding function indices",1,N],[6,"PerturbationVectors","","A collection of `PerturbationVector`s",N,N],[8,"ArgminSolver","argmin::prelude","Defines the interface to a solver. Usually, there is no…",N,N],[10,"apply","","apply cost function or operator to a parameter vector",2,N],[10,"gradient","","compute the gradient for a parameter vector",2,N],[10,"hessian","","compute the hessian for a parameter vector",2,N],[10,"modify","","modify the parameter vector",2,N],[10,"cur_param","","return current parameter vector",2,N],[10,"cur_grad","","return current gradient",2,N],[10,"cur_hessian","","return current gradient",2,N],[10,"set_cur_param","","set current parameter vector",2,N],[10,"set_cur_grad","","set current gradient",2,N],[10,"set_cur_hessian","","set current gradient",2,N],[10,"set_best_param","","set current parameter vector",2,N],[10,"run","","Execute the optimization algorithm.",2,[[["self"]],["result",["argminresult","error"]]]],[10,"run_fast","","Execute the optimization algorithm without Ctrl-C…",2,[[["self"]],["result",["argminresult","error"]]]],[10,"result","","Returns the best solution found during optimization.",2,[[["self"]],["argminresult"]]],[10,"set_termination_reason","","Set termination reason (doesn't terminate yet! -- this is…",2,N],[10,"terminate","","Evaluate all stopping criterions and return the…",2,[[["self"]],["terminationreason"]]],[10,"set_max_iters","","Set max number of iterations.",2,N],[10,"max_iters","","Get max number of iterations.",2,[[["self"]],["u64"]]],[10,"cur_iter","","Get current iteration number.",2,[[["self"]],["u64"]]],[10,"increment_iter","","Increment the iteration number by one",2,N],[10,"cur_cost","","Get current cost function value",2,[[["self"]],["f64"]]],[10,"set_cur_cost","","Get current cost function value",2,N],[10,"best_cost","","Get best cost function value",2,[[["self"]],["f64"]]],[10,"set_best_cost","","set best cost value",2,N],[10,"set_target_cost","","Set the target cost function value which is used as a…",2,N],[10,"add_logger","","Add a logger to the array of loggers",2,N],[10,"add_writer","","Add a writer to the array of writers",2,N],[10,"base_reset","","Reset the base of the algorithm to its initial state",2,N],[10,"increment_cost_func_count","","Increment the cost function evaluation count",2,N],[10,"increase_cost_func_count","","Increaese the cost function evaluation count by a given…",2,N],[10,"cost_func_count","","Return the cost function evaluation count",2,[[["self"]],["u64"]]],[10,"increment_grad_func_count","","Increment the gradient evaluation count",2,N],[10,"increase_grad_func_count","","Increase the gradient evaluation count by a given value",2,N],[10,"grad_func_count","","Return the gradient evaluation count",2,[[["self"]],["u64"]]],[10,"increment_hessian_func_count","","Increment the hessian evaluation count",2,N],[10,"increase_hessian_func_count","","Increase the hessian evaluation count by a given value",2,N],[10,"hessian_func_count","","Return the gradient evaluation count",2,[[["self"]],["u64"]]],[8,"ArgminNextIter","","Main part of every solver: `next_iter` computes one…",N,N],[16,"Parameters","","Parameter vectors",3,N],[16,"OperatorOutput","","Output of the operator",3,N],[16,"Hessian","","Hessian",3,N],[10,"next_iter","","Computes one iteration of the algorithm.",3,[[["self"]],["result",["argminiterationdata","error"]]]],[11,"init","","Initializes the algorithm",3,[[["self"]],["result",["error"]]]],[8,"ArgminLog","","Defince the interface every logger needs to expose",N,N],[10,"log_info","","Logs general information (a message `msg` and/or key-value…",4,[[["self"],["str"],["argminkv"]],["result",["error"]]]],[10,"log_iter","","Logs information from iterations. Only accepts key-value…",4,[[["self"],["argminkv"]],["result",["error"]]]],[8,"ArgminWrite","","Every writer (which is something that writes parameter…",N,N],[16,"Param","","",5,N],[10,"write","","Writes the parameter vector somewhere",5,N],[3,"ArgminIterationData","","The datastructure which is returned by the `next_iter`…",N,N],[8,"ArgminOperator","","This trait needs to be implemented for every operator/cost…",N,N],[16,"Parameters","","Type of the parameter vector",6,N],[16,"OperatorOutput","","Output of the operator. Most solvers expect `f64`.",6,N],[16,"Hessian","","Type of Hessian",6,N],[11,"apply","","Applies the operator/cost function to parameters",6,N],[11,"gradient","","Computes the gradient at the given parameters",6,N],[11,"hessian","","Computes the hessian at the given parameters",6,N],[11,"modify","","Modifies a parameter vector. Comes with a variable that…",6,N],[3,"NoOperator","","",N,N],[8,"ArgminLineSearch","","Defines a common interface to line search methods.…",N,N],[10,"set_initial_parameter","","Set the initial parameter (starting point)",7,N],[10,"set_search_direction","","Set the search direction",7,N],[10,"set_initial_alpha","","Set the initial step length",7,[[["self"],["f64"]],["result",["error"]]]],[10,"set_initial_cost","","Set the cost function value at the starting point as…",7,N],[10,"set_initial_gradient","","Set the gradient at the starting point as opposed to…",7,N],[10,"calc_initial_cost","","calculate the initial cost function value using an…",7,[[["self"]],["result",["error"]]]],[10,"calc_initial_gradient","","calculate the initial gradient using an operator as…",7,[[["self"]],["result",["error"]]]],[8,"ArgminTrustRegion","","Defines a common interface to methods which calculate…",N,N],[10,"set_radius","","Set the initial step length",8,N],[10,"set_grad","","Set the gradient at the starting point",8,N],[10,"set_hessian","","Set the gradient at the starting point",8,N],[8,"ArgminNLCGBetaUpdate","","Every method for the update of beta needs to implement…",N,N],[10,"update","","Update beta Parameter 1: \\nabla f_k Parameter 2: \\nabla…",9,[[["self"],["t"],["t"],["t"]],["f64"]]],[8,"ArgminScale","","Scale `self` by a `U`",N,N],[10,"scale","","Scale `self` by a `U`",10,[[["self"],["u"]],["self"]]],[8,"ArgminScaledSub","","Subtract a `T` scaled by an `U` from `self`",N,N],[10,"scaled_sub","","Subtract a `T` scaled by an `U` from `self`",11,[[["self"],["u"],["t"]],["self"]]],[3,"ArgminBase","","Storage for data needed by most solvers",N,N],[14,"make_kv","","Creates an `ArgminKV` at compile time in order to avoid…",N,N],[8,"ArgminZero","","Return param vector of all zeros (for now, this is a hack.…",N,N],[10,"zero","","Return param vector of all zeros",12,[[["self"]],["self"]]],[14,"check_param","","Release an `T` from an `Option<T>` if it is not `None`. If…",N,N],[8,"ArgminAdd","","Add a `T` to `self`",N,N],[10,"add","","Add a `T` to `self`",13,[[["self"],["t"]],["self"]]],[8,"ArgminDot","","Dot/scalar product of `T` and `self`",N,N],[10,"dot","","Dot/scalar product of `T` and `self`",14,[[["self"],["t"]],["u"]]],[8,"ArgminWeightedDot","","Dot/scalar product of `T` and `self` weighted by W (p^TWv)",N,N],[10,"weighted_dot","","Dot/scalar product of `T` and `self`",15,[[["self"],["v"],["t"]],["u"]]],[3,"ArgminLogger","","Container for `ArgminLog`gers",N,N],[8,"ArgminEye","","",N,N],[10,"eye","","",16,[[["usize"]],["self"]]],[10,"eye_like","","",16,[[["self"]],["self"]]],[8,"ArgminMul","","",N,N],[10,"amul","","",17,[[["self"],["t"]],["u"]]],[3,"Error","","The `Error` type, which can contain any failure.",N,N],[3,"ArgminResult","","Return struct for all solvers.",N,N],[12,"param","","Final parameter vector",18,N],[12,"cost","","Final cost value",18,N],[12,"iters","","Number of iterations",18,N],[12,"terminated","","Indicated whether it terminated or not",18,N],[12,"termination_reason","","Reason of termination",18,N],[0,"modcholesky","","Modified Cholesky decompositions Modified Cholesky…",N,N],[8,"GershgorinCircles","argmin::prelude::modcholesky","Gershgorin circles",N,N],[10,"gershgorin_circles","","Computes the Gershgorin Circles of a matrix",19,[[["self"]],["vec"]]],[8,"ModCholeskySE90","","Schnabel & Eskow algorithm (1990)",N,N],[11,"mod_cholesky_se90","","Computes the modified Cholesky decomposition with the SE90…",20,[[["self"]],["decomposition"]]],[8,"ModCholeskyGMW81","","Gill, Murray and Wright (1981)",N,N],[11,"mod_cholesky_gmw81","","Computes the modified Cholesky decomposition with the…",21,[[["self"]],["decomposition"]]],[3,"Decomposition","","",N,N],[12,"l","","",22,N],[12,"e","","",22,N],[12,"p","","",22,N],[8,"ModCholeskySE99","","Schnabel & Eskow algorithm (1999)",N,N],[11,"mod_cholesky_se99","","Computes the modified Cholesky decomposition with the SE99…",23,[[["self"]],["decomposition"]]],[0,"utils","","Utility functions",N,N],[5,"eigenvalues_2x2","argmin::prelude::modcholesky::utils","Computes the Eigenvalues of a 2x2 matrix",N,N],[5,"swap_columns","","Swaps columns `idx1` and `idx2` of matrix `mat`",N,N],[5,"swap_rows","","Swaps rows `idx1` and `idx2` of matrix `mat`",N,N],[5,"index_of_largest","","Returns the index of the largest element in a 1D array",N,[[["arraybase"]],["usize"]]],[5,"index_of_largest_abs","","Returns the index of the element with the largest absolute…",N,[[["arraybase"]],["usize"]]],[5,"index_to_permutation_mat","","Returns the permutation matrix for a vector of permuted…",N,N],[5,"diag_mat_from_arr","","Builds a diagonal matrix from a 1D slice",N,N],[5,"random_householder","","Returns a random Householder matrix of dimension `dim` and…",N,[[["usize"],["u8"]],["arraybase",["ownedrepr","dim"]]]],[5,"random_diagonal","","Returns a random diagonal matrix with Eigenvalues…",N,N],[3,"ArgminSlogLogger","argmin::prelude","A logger based on `slog`",N,N],[4,"ArgminError","","",N,N],[13,"InvalidParameter","","Indicates and invalid parameter",24,N],[12,"text","argmin::prelude::ArgminError","",24,N],[13,"NotImplemented","argmin::prelude","Indicates that a function is not implemented",24,N],[12,"text","argmin::prelude::ArgminError","",24,N],[13,"NotInitialized","argmin::prelude","Indicates that a function is not initialized",24,N],[12,"text","argmin::prelude::ArgminError","",24,N],[13,"ConditionViolated","argmin::prelude","Indicates that a condition is violated",24,N],[12,"text","argmin::prelude::ArgminError","",24,N],[13,"ImpossibleError","argmin::prelude","Indicates an impossible error",24,N],[12,"text","argmin::prelude::ArgminError","",24,N],[3,"ArgminWriter","argmin::prelude","",N,N],[8,"ArgminSub","","Subtract a `T` from `self`",N,N],[10,"sub","","Subtract a `T` from `self`",25,[[["self"],["t"]],["self"]]],[5,"set_handler","argmin::prelude::ctrlc","Register signal handler for Ctrl-C.",N,[[["f"]],["result",["error"]]]],[4,"Error","","Ctrl-C error.",N,N],[13,"NoSuchSignal","","Signal could not be found from the system.",26,N],[13,"MultipleHandlers","","Ctrl-C signal handler already registered.",26,N],[13,"System","","Unexpected system error.",26,N],[4,"SignalType","","A cross-platform way to represent Ctrl-C or program…",N,N],[13,"Ctrlc","","Ctrl-C",27,N],[13,"Termination","","Program termination Maps to `SIGTERM` on *nix,…",27,N],[13,"Other","","Other signal/event using platform-specific data",27,N],[6,"Signal","","Platform specific signal type",N,N],[8,"ArgminNorm","argmin::prelude","Compute the l2-norm (`U`) of `self`",N,N],[10,"norm","","Compute the l2-norm (`U`) of `self`",28,[[["self"]],["u"]]],[3,"WriteToFile","","",N,N],[8,"ArgminScaledAdd","","Add a `T` scaled by an `U` to `self`",N,N],[10,"scaled_add","","Add a `T` scaled by an `U` to `self`",29,[[["self"],["u"],["t"]],["self"]]],[8,"ArgminInv","","Compute the inverse (`T`) of `self`",N,N],[10,"ainv","","",30,[[["self"]],["result",["error"]]]],[3,"ArgminKV","","A simple key-value storage",N,N],[12,"kv","","The actual key value storage",31,N],[4,"TerminationReason","","Indicates why the optimization algorithm stopped",N,N],[13,"NotTerminated","","In case it has not terminated yet",32,N],[13,"MaxItersReached","","Maximum number of iterations reached",32,N],[13,"TargetCostReached","","Target cost function value reached",32,N],[13,"TargetPrecisionReached","","Target precision reached",32,N],[13,"AcceptedStallIterExceeded","","Acceped stall iter exceeded",32,N],[13,"BestStallIterExceeded","","Best stall iter exceeded",32,N],[13,"LineSearchConditionMet","","Condition for Line search met",32,N],[13,"Aborted","","Aborted",32,N],[0,"solver","argmin","Solvers",N,N],[0,"conjugategradient","argmin::solver","Conjugate Gradient methods",N,N],[0,"cg","argmin::solver::conjugategradient","Conjugate gradient method # References:",N,N],[3,"ConjugateGradient","argmin::solver::conjugategradient::cg","The conjugate gradient method is a solver for systems of…",N,N],[11,"new","","Constructor",33,[[["argminoperator"],["t"],["t"]],["result",["error"]]]],[11,"p","","Return the current search direction (This is needed by…",33,[[["self"]],["t"]]],[11,"p_prev","","Return the previous search direction (This is needed by…",33,[[["self"]],["t"]]],[11,"residual","","Return the current residual (This is needed by NewtonCG…",33,[[["self"]],["t"]]],[0,"nonlinear_cg","argmin::solver::conjugategradient","Nonlinear conjugate gradient method Important TODO: Find…",N,N],[3,"NonlinearConjugateGradient","argmin::solver::conjugategradient::nonlinear_cg","The nonlinear conjugate gradient is a generalization of…",N,N],[11,"new","","Constructor (Polak Ribiere Conjugate Gradient (PR-CG))",34,[[["argminoperator"],["t"]],["result",["error"]]]],[11,"new_pr","","New PolakRibiere CG (PR-CG)",34,[[["argminoperator"],["t"]],["result",["error"]]]],[11,"new_prplus","","New PolakRibierePlus CG (PR+-CG)",34,[[["argminoperator"],["t"]],["result",["error"]]]],[11,"new_fr","","New FletcherReeves CG (FR-CG)",34,[[["argminoperator"],["t"]],["result",["error"]]]],[11,"new_hs","","New HestenesStiefel CG (HS-CG)",34,[[["argminoperator"],["t"]],["result",["error"]]]],[11,"set_linesearch","","Specify line search method",34,[[["self"],["box",["argminlinesearch"]]],["self"]]],[11,"set_beta_update","","Specify beta update method",34,[[["self"],["box",["argminnlcgbetaupdate"]]],["self"]]],[11,"set_restart_iters","","Specifiy the number of iterations after which a restart…",34,[[["self"],["u64"]],["self"]]],[11,"set_restart_orthogonality","","Set the value for the orthogonality measure. Setting this…",34,[[["self"],["f64"]],["self"]]],[0,"beta","argmin::solver::conjugategradient","Beta update methods for nonlinear CG # Beta update methods",N,N],[3,"FletcherReeves","argmin::solver::conjugategradient::beta","Fletcher and Reeves (FR) method TODO: Reference",N,N],[3,"PolakRibiere","","Polak and Ribiere (PR) method TODO: Reference",N,N],[3,"PolakRibierePlus","","Polak and Ribiere Plus (PR+) method TODO: Reference",N,N],[3,"HestenesStiefel","","Hestenes and Stiefel (HS) method TODO: Reference",N,N],[11,"new","","Constructor",35,[[],["self"]]],[11,"new","","Constructor",36,[[],["self"]]],[11,"new","","Constructor",37,[[],["self"]]],[11,"new","","Constructor",38,[[],["self"]]],[0,"gradientdescent","argmin::solver","Gradient descent methods",N,N],[0,"steepestdescent","argmin::solver::gradientdescent","Steepest Descent method",N,N],[3,"SteepestDescent","argmin::solver::gradientdescent::steepestdescent","Steepest descent iteratively takes steps in the direction…",N,N],[11,"new","","Constructor",39,[[["argminoperator"],["t"]],["result",["error"]]]],[11,"set_linesearch","","Specify line search method",39,[[["self"],["box",["argminlinesearch"]]],["self"]]],[0,"landweber","argmin::solver","Landweber iteration",N,N],[3,"Landweber","argmin::solver::landweber","The Landweber iteration is a solver for ill-posed linear…",N,N],[11,"new","","Constructor",40,[[["argminoperator"],["f64"],["t"]],["result",["error"]]]],[0,"linesearch","argmin::solver","Line search methods",N,N],[0,"backtracking","argmin::solver::linesearch","Backtracking line search algorithm * Backtracking line…",N,N],[3,"BacktrackingLineSearch","argmin::solver::linesearch::backtracking","The Backtracking line search is a simple method to find a…",N,N],[11,"new","","Constructor",41,[[["argminoperator"]],["self"]]],[11,"set_cur_grad","","set current gradient value",41,[[["self"],["t"]],["self"]]],[11,"set_rho","","Set contraction factor rho",41,[[["self"],["f64"]],["result",["error"]]]],[11,"set_condition","","Set condition",41,[[["self"],["box",["linesearchcondition"]]],["self"]]],[0,"condition","argmin::solver::linesearch","Acceptance conditions # References:",N,N],[3,"ArmijoCondition","argmin::solver::linesearch::condition","Armijo Condition",N,N],[3,"WolfeCondition","","Wolfe Condition",N,N],[3,"StrongWolfeCondition","","Strong Wolfe conditions",N,N],[3,"GoldsteinCondition","","Goldstein conditions",N,N],[8,"LineSearchCondition","","Needs to be implemented by everything that wants to be a…",N,N],[10,"eval","","Evaluate the condition",42,[[["self"],["f64"],["t"],["f64"],["t"],["t"],["f64"]],["bool"]]],[10,"requires_cur_grad","","Indicates whether this condition requires the computation…",42,[[["self"]],["bool"]]],[11,"new","","Constructor",43,[[["f64"]],["result",["error"]]]],[11,"new","","Constructor",44,[[["f64"],["f64"]],["result",["error"]]]],[11,"new","","Constructor",45,[[["f64"],["f64"]],["result",["error"]]]],[11,"new","","Constructor",46,[[["f64"]],["result",["error"]]]],[0,"hagerzhang","argmin::solver::linesearch","Hager-Zhang line search algorithm * Hager-Zhang line search",N,N],[3,"HagerZhangLineSearch","argmin::solver::linesearch::hagerzhang","The Hager-Zhang line search is a method to find a step…",N,N],[11,"new","","Constructor",47,[[["argminoperator"]],["self"]]],[11,"set_cur_grad","","set current gradient value",47,[[["self"],["t"]],["self"]]],[11,"set_delta","","set delta",47,[[["self"],["f64"]],["result",["error"]]]],[11,"set_sigma","","set sigma",47,[[["self"],["f64"]],["result",["error"]]]],[11,"set_epsilon","","set epsilon",47,[[["self"],["f64"]],["result",["error"]]]],[11,"set_theta","","set theta",47,[[["self"],["f64"]],["result",["error"]]]],[11,"set_gamma","","set gamma",47,[[["self"],["f64"]],["result",["error"]]]],[11,"set_eta","","set eta",47,[[["self"],["f64"]],["result",["error"]]]],[11,"set_alpha_min_max","","set alpha limits",47,[[["self"],["f64"],["f64"]],["result",["error"]]]],[0,"morethuente","argmin::solver::linesearch","More-Thuente line search algorithm * More-Thuente line…",N,N],[3,"MoreThuenteLineSearch","argmin::solver::linesearch::morethuente","The More-Thuente line search is a method to find a step…",N,N],[11,"new","","Constructor",48,[[["argminoperator"]],["self"]]],[11,"set_cur_grad","","set current gradient value",48,[[["self"],["t"]],["self"]]],[11,"set_c","","Set c1 and c2 where 0 < c1 < c2 < 1.",48,[[["self"],["f64"],["f64"]],["result",["error"]]]],[11,"set_alpha_min_max","","set alpha limits",48,[[["self"],["f64"],["f64"]],["result",["error"]]]],[0,"newton","argmin::solver","Newton Methods",N,N],[0,"newton_cg","argmin::solver::newton","Newton-CG method TODO: Stop when search direction is close…",N,N],[3,"NewtonCG","argmin::solver::newton::newton_cg","The Newton-CG method (also called truncated Newton method)…",N,N],[11,"new","","Constructor",49,[[["argminoperator"],["t"]],["self"]]],[11,"set_linesearch","","Specify line search method",49,[[["self"],["box",["argminlinesearch"]]],["self"]]],[11,"set_curvature_threshold","","Set curvature threshold",49,[[["self"],["f64"]],["self"]]],[0,"newton_method","argmin::solver::newton","Newton's method # References:",N,N],[3,"Newton","argmin::solver::newton::newton_method","Newton's method iteratively finds the stationary points of…",N,N],[11,"new","","Constructor",50,[[["argminoperator"],["t"]],["self"]]],[11,"set_gamma","","set gamma",50,[[["self"],["f64"]],["result",["error"]]]],[0,"quasinewton","argmin::solver","Quasi-Newton methods",N,N],[0,"bfgs","argmin::solver::quasinewton","References:",N,N],[3,"BFGS","argmin::solver::quasinewton::bfgs","BFGS method",N,N],[11,"new","","Constructor",51,[[["argminoperator"],["t"],["h"]],["self"]]],[11,"set_linesearch","","Specify line search method",51,[[["self"],["box",["argminlinesearch"]]],["self"]]],[0,"simulatedannealing","argmin::solver","",N,N],[3,"SimulatedAnnealing","argmin::solver::simulatedannealing","Simulated Annealing",N,N],[4,"SATempFunc","","Temperature functions for Simulated Annealing.",N,N],[13,"TemperatureFast","","`t_i = t_init / i`",52,N],[13,"Boltzmann","","`t_i = t_init / ln(i)`",52,N],[13,"Exponential","","`t_i = t_init * x^i`",52,N],[13,"Custom","","User-provided temperature function. The first parameter…",52,N],[11,"new","","Constructor",53,[[["argminoperator"],["t"],["f64"]],["result",["error"]]]],[11,"temp_func","","Set temperature function to one of the options in…",53,[[["self"],["satempfunc"]],["self"]]],[11,"stall_accepted","","The optimization stops after there has been no accepted…",53,[[["self"],["u64"]],["self"]]],[11,"stall_best","","The optimization stops after there has been no new best…",53,[[["self"],["u64"]],["self"]]],[11,"reannealing_fixed","","Start reannealing after `iter` iterations",53,[[["self"],["u64"]],["self"]]],[11,"reannealing_accepted","","Start reannealing after no accepted solution has been…",53,[[["self"],["u64"]],["self"]]],[11,"reannealing_best","","Start reannealing after no new best solution has been…",53,[[["self"],["u64"]],["self"]]],[0,"trustregion","argmin::solver","Argmin Trust region methods",N,N],[5,"reduction_ratio","argmin::solver::trustregion","Computes reduction ratio",N,[[["f64"],["f64"],["f64"],["f64"]],["f64"]]],[0,"cauchypoint","","Cauchy Point # References:",N,N],[3,"CauchyPoint","argmin::solver::trustregion::cauchypoint","The Cauchy point is the minimum of the quadratic…",N,N],[11,"new","","Constructor",54,[[["argminoperator"]],["self"]]],[0,"dogleg","argmin::solver::trustregion","Dogleg method # References:",N,N],[3,"Dogleg","argmin::solver::trustregion::dogleg","The Dogleg method computes the intersection of the trust…",N,N],[11,"new","","Constructor",55,[[["argminoperator"]],["self"]]],[0,"steihaug","argmin::solver::trustregion","Steihaug method # References:",N,N],[3,"Steihaug","argmin::solver::trustregion::steihaug","The Steihaug method is a conjugate gradients based…",N,N],[11,"new","","Constructor",56,[[["argminoperator"]],["self"]]],[11,"set_epsilon","","Set epsilon",56,[[["self"],["f64"]],["result",["error"]]]],[0,"trustregion_method","argmin::solver::trustregion","Trust region solver # References:",N,N],[3,"TrustRegion","argmin::solver::trustregion::trustregion_method","The trust region method approximates the cost function…",N,N],[11,"new","","Constructor",57,[[["argminoperator"],["t"]],["self"]]],[11,"set_radius","","set radius",57,[[["self"],["f64"]],["self"]]],[11,"set_max_radius","","Set maximum radius",57,[[["self"],["f64"]],["self"]]],[11,"set_eta","","Set eta",57,[[["self"],["f64"]],["result",["error"]]]],[11,"set_subproblem","","Set subproblem",57,[[["self"],["box",["argmintrustregion"]]],["self"]]],[0,"testfunctions","argmin","Testfunctions # Testfunctions",N,N],[5,"mccorminck","argmin::testfunctions","McCorminck test function",N,N],[5,"himmelblau","","Himmelblau test function",N,N],[5,"sphere_derivative","","Derivative of sphere test function",N,N],[5,"schaffer_n2","","Schaffer test function No. 2",N,N],[5,"holder_table","","Holder table test function",N,N],[5,"rosenbrock_2d_hessian","","Hessian of 2D Rosenbrock function",N,N],[5,"rastrigin","","Rastrigin test function",N,N],[5,"rosenbrock_2d","","2D Rosenbrock test function",N,N],[5,"ackley","","Ackley test function",N,N],[5,"zero","","Zero test function",N,N],[5,"goldsteinprice","","Goldstein-Price test function",N,N],[5,"matyas","","Matyas test function",N,N],[5,"schaffer_n4","","Schaffer test function No. 4",N,N],[5,"booth","","Booth test function",N,N],[5,"eggholder","","Eggholder test function",N,N],[5,"picheny","","Picheny test function",N,N],[5,"rastrigin_a","","Rastrigin test function",N,N],[5,"levy_n13","","Levy test function No. 13",N,N],[5,"cross_in_tray","","Cross-in-tray test function",N,N],[5,"sphere","","Sphere test function",N,N],[5,"zero_derivative","","Derivative of zero test function",N,N],[5,"threehumpcamel","","Three-hump camel test function",N,N],[5,"styblinski_tang","","Styblinski-Tang test function",N,N],[5,"levy","","Levy test function",N,N],[5,"rosenbrock_2d_derivative","","Derivative of 2D Rosenbrock function",N,N],[5,"easom","","Easom test function",N,N],[5,"rosenbrock","","Multidimensional Rosenbrock test function",N,N],[5,"ackley_param","","Ackley test function",N,N],[5,"bukin_n6","","Bukin test function No. 6",N,N],[5,"beale","","Beale test function",N,N],[11,"from","argmin::prelude::finitediff","",1,[[["t"]],["t"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,N],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"from","argmin::prelude","",58,[[["t"]],["t"]]],[11,"into","","",58,[[["self"]],["u"]]],[11,"try_from","","",58,[[["u"]],["result"]]],[11,"borrow","","",58,[[["self"]],["t"]]],[11,"borrow_mut","","",58,[[["self"]],["t"]]],[11,"try_into","","",58,[[["self"]],["result"]]],[11,"get_type_id","","",58,[[["self"]],["typeid"]]],[11,"from","","",59,[[["t"]],["t"]]],[11,"into","","",59,[[["self"]],["u"]]],[11,"to_owned","","",59,[[["self"]],["t"]]],[11,"clone_into","","",59,N],[11,"try_from","","",59,[[["u"]],["result"]]],[11,"borrow","","",59,[[["self"]],["t"]]],[11,"borrow_mut","","",59,[[["self"]],["t"]]],[11,"try_into","","",59,[[["self"]],["result"]]],[11,"get_type_id","","",59,[[["self"]],["typeid"]]],[11,"from","","",60,[[["t"]],["t"]]],[11,"into","","",60,[[["self"]],["u"]]],[11,"try_from","","",60,[[["u"]],["result"]]],[11,"borrow","","",60,[[["self"]],["t"]]],[11,"borrow_mut","","",60,[[["self"]],["t"]]],[11,"try_into","","",60,[[["self"]],["result"]]],[11,"get_type_id","","",60,[[["self"]],["typeid"]]],[11,"from","","",61,[[["t"]],["t"]]],[11,"into","","",61,[[["self"]],["u"]]],[11,"try_from","","",61,[[["u"]],["result"]]],[11,"borrow","","",61,[[["self"]],["t"]]],[11,"borrow_mut","","",61,[[["self"]],["t"]]],[11,"try_into","","",61,[[["self"]],["result"]]],[11,"get_type_id","","",61,[[["self"]],["typeid"]]],[11,"from","","",62,[[["t"]],["t"]]],[11,"into","","",62,[[["self"]],["u"]]],[11,"to_string","","",62,[[["self"]],["string"]]],[11,"try_from","","",62,[[["u"]],["result"]]],[11,"borrow","","",62,[[["self"]],["t"]]],[11,"borrow_mut","","",62,[[["self"]],["t"]]],[11,"try_into","","",62,[[["self"]],["result"]]],[11,"get_type_id","","",62,[[["self"]],["typeid"]]],[11,"as_fail","","",62,[[["self"]],["fail"]]],[11,"from","","",18,[[["t"]],["t"]]],[11,"into","","",18,[[["self"]],["u"]]],[11,"to_owned","","",18,[[["self"]],["t"]]],[11,"clone_into","","",18,N],[11,"try_from","","",18,[[["u"]],["result"]]],[11,"borrow","","",18,[[["self"]],["t"]]],[11,"borrow_mut","","",18,[[["self"]],["t"]]],[11,"try_into","","",18,[[["self"]],["result"]]],[11,"get_type_id","","",18,[[["self"]],["typeid"]]],[11,"from","argmin::prelude::modcholesky","",22,[[["t"]],["t"]]],[11,"into","","",22,[[["self"]],["u"]]],[11,"try_from","","",22,[[["u"]],["result"]]],[11,"borrow","","",22,[[["self"]],["t"]]],[11,"borrow_mut","","",22,[[["self"]],["t"]]],[11,"try_into","","",22,[[["self"]],["result"]]],[11,"get_type_id","","",22,[[["self"]],["typeid"]]],[11,"from","argmin::prelude","",63,[[["t"]],["t"]]],[11,"into","","",63,[[["self"]],["u"]]],[11,"try_from","","",63,[[["u"]],["result"]]],[11,"borrow","","",63,[[["self"]],["t"]]],[11,"borrow_mut","","",63,[[["self"]],["t"]]],[11,"try_into","","",63,[[["self"]],["result"]]],[11,"get_type_id","","",63,[[["self"]],["typeid"]]],[11,"from","","",24,[[["t"]],["t"]]],[11,"into","","",24,[[["self"]],["u"]]],[11,"to_string","","",24,[[["self"]],["string"]]],[11,"try_from","","",24,[[["u"]],["result"]]],[11,"borrow","","",24,[[["self"]],["t"]]],[11,"borrow_mut","","",24,[[["self"]],["t"]]],[11,"try_into","","",24,[[["self"]],["result"]]],[11,"get_type_id","","",24,[[["self"]],["typeid"]]],[11,"as_fail","","",24,[[["self"]],["fail"]]],[11,"from","","",64,[[["t"]],["t"]]],[11,"into","","",64,[[["self"]],["u"]]],[11,"try_from","","",64,[[["u"]],["result"]]],[11,"borrow","","",64,[[["self"]],["t"]]],[11,"borrow_mut","","",64,[[["self"]],["t"]]],[11,"try_into","","",64,[[["self"]],["result"]]],[11,"get_type_id","","",64,[[["self"]],["typeid"]]],[11,"from","argmin::prelude::ctrlc","",26,[[["t"]],["t"]]],[11,"into","","",26,[[["self"]],["u"]]],[11,"to_string","","",26,[[["self"]],["string"]]],[11,"try_from","","",26,[[["u"]],["result"]]],[11,"borrow","","",26,[[["self"]],["t"]]],[11,"borrow_mut","","",26,[[["self"]],["t"]]],[11,"try_into","","",26,[[["self"]],["result"]]],[11,"get_type_id","","",26,[[["self"]],["typeid"]]],[11,"as_fail","","",26,[[["self"]],["fail"]]],[11,"from","","",27,[[["t"]],["t"]]],[11,"into","","",27,[[["self"]],["u"]]],[11,"try_from","","",27,[[["u"]],["result"]]],[11,"borrow","","",27,[[["self"]],["t"]]],[11,"borrow_mut","","",27,[[["self"]],["t"]]],[11,"try_into","","",27,[[["self"]],["result"]]],[11,"get_type_id","","",27,[[["self"]],["typeid"]]],[11,"from","argmin::prelude","",65,[[["t"]],["t"]]],[11,"into","","",65,[[["self"]],["u"]]],[11,"try_from","","",65,[[["u"]],["result"]]],[11,"borrow","","",65,[[["self"]],["t"]]],[11,"borrow_mut","","",65,[[["self"]],["t"]]],[11,"try_into","","",65,[[["self"]],["result"]]],[11,"get_type_id","","",65,[[["self"]],["typeid"]]],[11,"from","","",31,[[["t"]],["t"]]],[11,"into","","",31,[[["self"]],["u"]]],[11,"to_owned","","",31,[[["self"]],["t"]]],[11,"clone_into","","",31,N],[11,"try_from","","",31,[[["u"]],["result"]]],[11,"borrow","","",31,[[["self"]],["t"]]],[11,"borrow_mut","","",31,[[["self"]],["t"]]],[11,"try_into","","",31,[[["self"]],["result"]]],[11,"get_type_id","","",31,[[["self"]],["typeid"]]],[11,"from","","",32,[[["t"]],["t"]]],[11,"into","","",32,[[["self"]],["u"]]],[11,"to_owned","","",32,[[["self"]],["t"]]],[11,"clone_into","","",32,N],[11,"try_from","","",32,[[["u"]],["result"]]],[11,"borrow","","",32,[[["self"]],["t"]]],[11,"borrow_mut","","",32,[[["self"]],["t"]]],[11,"try_into","","",32,[[["self"]],["result"]]],[11,"get_type_id","","",32,[[["self"]],["typeid"]]],[11,"from","argmin::solver::conjugategradient::cg","",33,[[["t"]],["t"]]],[11,"into","","",33,[[["self"]],["u"]]],[11,"try_from","","",33,[[["u"]],["result"]]],[11,"borrow","","",33,[[["self"]],["t"]]],[11,"borrow_mut","","",33,[[["self"]],["t"]]],[11,"try_into","","",33,[[["self"]],["result"]]],[11,"get_type_id","","",33,[[["self"]],["typeid"]]],[11,"from","argmin::solver::conjugategradient::nonlinear_cg","",34,[[["t"]],["t"]]],[11,"into","","",34,[[["self"]],["u"]]],[11,"try_from","","",34,[[["u"]],["result"]]],[11,"borrow","","",34,[[["self"]],["t"]]],[11,"borrow_mut","","",34,[[["self"]],["t"]]],[11,"try_into","","",34,[[["self"]],["result"]]],[11,"get_type_id","","",34,[[["self"]],["typeid"]]],[11,"from","argmin::solver::conjugategradient::beta","",35,[[["t"]],["t"]]],[11,"into","","",35,[[["self"]],["u"]]],[11,"try_from","","",35,[[["u"]],["result"]]],[11,"borrow","","",35,[[["self"]],["t"]]],[11,"borrow_mut","","",35,[[["self"]],["t"]]],[11,"try_into","","",35,[[["self"]],["result"]]],[11,"get_type_id","","",35,[[["self"]],["typeid"]]],[11,"from","","",36,[[["t"]],["t"]]],[11,"into","","",36,[[["self"]],["u"]]],[11,"try_from","","",36,[[["u"]],["result"]]],[11,"borrow","","",36,[[["self"]],["t"]]],[11,"borrow_mut","","",36,[[["self"]],["t"]]],[11,"try_into","","",36,[[["self"]],["result"]]],[11,"get_type_id","","",36,[[["self"]],["typeid"]]],[11,"from","","",37,[[["t"]],["t"]]],[11,"into","","",37,[[["self"]],["u"]]],[11,"try_from","","",37,[[["u"]],["result"]]],[11,"borrow","","",37,[[["self"]],["t"]]],[11,"borrow_mut","","",37,[[["self"]],["t"]]],[11,"try_into","","",37,[[["self"]],["result"]]],[11,"get_type_id","","",37,[[["self"]],["typeid"]]],[11,"from","","",38,[[["t"]],["t"]]],[11,"into","","",38,[[["self"]],["u"]]],[11,"try_from","","",38,[[["u"]],["result"]]],[11,"borrow","","",38,[[["self"]],["t"]]],[11,"borrow_mut","","",38,[[["self"]],["t"]]],[11,"try_into","","",38,[[["self"]],["result"]]],[11,"get_type_id","","",38,[[["self"]],["typeid"]]],[11,"from","argmin::solver::gradientdescent::steepestdescent","",39,[[["t"]],["t"]]],[11,"into","","",39,[[["self"]],["u"]]],[11,"try_from","","",39,[[["u"]],["result"]]],[11,"borrow","","",39,[[["self"]],["t"]]],[11,"borrow_mut","","",39,[[["self"]],["t"]]],[11,"try_into","","",39,[[["self"]],["result"]]],[11,"get_type_id","","",39,[[["self"]],["typeid"]]],[11,"from","argmin::solver::landweber","",40,[[["t"]],["t"]]],[11,"into","","",40,[[["self"]],["u"]]],[11,"try_from","","",40,[[["u"]],["result"]]],[11,"borrow","","",40,[[["self"]],["t"]]],[11,"borrow_mut","","",40,[[["self"]],["t"]]],[11,"try_into","","",40,[[["self"]],["result"]]],[11,"get_type_id","","",40,[[["self"]],["typeid"]]],[11,"from","argmin::solver::linesearch::backtracking","",41,[[["t"]],["t"]]],[11,"into","","",41,[[["self"]],["u"]]],[11,"try_from","","",41,[[["u"]],["result"]]],[11,"borrow","","",41,[[["self"]],["t"]]],[11,"borrow_mut","","",41,[[["self"]],["t"]]],[11,"try_into","","",41,[[["self"]],["result"]]],[11,"get_type_id","","",41,[[["self"]],["typeid"]]],[11,"from","argmin::solver::linesearch::condition","",43,[[["t"]],["t"]]],[11,"into","","",43,[[["self"]],["u"]]],[11,"try_from","","",43,[[["u"]],["result"]]],[11,"borrow","","",43,[[["self"]],["t"]]],[11,"borrow_mut","","",43,[[["self"]],["t"]]],[11,"try_into","","",43,[[["self"]],["result"]]],[11,"get_type_id","","",43,[[["self"]],["typeid"]]],[11,"from","","",44,[[["t"]],["t"]]],[11,"into","","",44,[[["self"]],["u"]]],[11,"try_from","","",44,[[["u"]],["result"]]],[11,"borrow","","",44,[[["self"]],["t"]]],[11,"borrow_mut","","",44,[[["self"]],["t"]]],[11,"try_into","","",44,[[["self"]],["result"]]],[11,"get_type_id","","",44,[[["self"]],["typeid"]]],[11,"from","","",45,[[["t"]],["t"]]],[11,"into","","",45,[[["self"]],["u"]]],[11,"try_from","","",45,[[["u"]],["result"]]],[11,"borrow","","",45,[[["self"]],["t"]]],[11,"borrow_mut","","",45,[[["self"]],["t"]]],[11,"try_into","","",45,[[["self"]],["result"]]],[11,"get_type_id","","",45,[[["self"]],["typeid"]]],[11,"from","","",46,[[["t"]],["t"]]],[11,"into","","",46,[[["self"]],["u"]]],[11,"try_from","","",46,[[["u"]],["result"]]],[11,"borrow","","",46,[[["self"]],["t"]]],[11,"borrow_mut","","",46,[[["self"]],["t"]]],[11,"try_into","","",46,[[["self"]],["result"]]],[11,"get_type_id","","",46,[[["self"]],["typeid"]]],[11,"from","argmin::solver::linesearch::hagerzhang","",47,[[["t"]],["t"]]],[11,"into","","",47,[[["self"]],["u"]]],[11,"try_from","","",47,[[["u"]],["result"]]],[11,"borrow","","",47,[[["self"]],["t"]]],[11,"borrow_mut","","",47,[[["self"]],["t"]]],[11,"try_into","","",47,[[["self"]],["result"]]],[11,"get_type_id","","",47,[[["self"]],["typeid"]]],[11,"from","argmin::solver::linesearch::morethuente","",48,[[["t"]],["t"]]],[11,"into","","",48,[[["self"]],["u"]]],[11,"try_from","","",48,[[["u"]],["result"]]],[11,"borrow","","",48,[[["self"]],["t"]]],[11,"borrow_mut","","",48,[[["self"]],["t"]]],[11,"try_into","","",48,[[["self"]],["result"]]],[11,"get_type_id","","",48,[[["self"]],["typeid"]]],[11,"from","argmin::solver::newton::newton_cg","",49,[[["t"]],["t"]]],[11,"into","","",49,[[["self"]],["u"]]],[11,"try_from","","",49,[[["u"]],["result"]]],[11,"borrow","","",49,[[["self"]],["t"]]],[11,"borrow_mut","","",49,[[["self"]],["t"]]],[11,"try_into","","",49,[[["self"]],["result"]]],[11,"get_type_id","","",49,[[["self"]],["typeid"]]],[11,"from","argmin::solver::newton::newton_method","",50,[[["t"]],["t"]]],[11,"into","","",50,[[["self"]],["u"]]],[11,"try_from","","",50,[[["u"]],["result"]]],[11,"borrow","","",50,[[["self"]],["t"]]],[11,"borrow_mut","","",50,[[["self"]],["t"]]],[11,"try_into","","",50,[[["self"]],["result"]]],[11,"get_type_id","","",50,[[["self"]],["typeid"]]],[11,"from","argmin::solver::quasinewton::bfgs","",51,[[["t"]],["t"]]],[11,"into","","",51,[[["self"]],["u"]]],[11,"try_from","","",51,[[["u"]],["result"]]],[11,"borrow","","",51,[[["self"]],["t"]]],[11,"borrow_mut","","",51,[[["self"]],["t"]]],[11,"try_into","","",51,[[["self"]],["result"]]],[11,"get_type_id","","",51,[[["self"]],["typeid"]]],[11,"from","argmin::solver::simulatedannealing","",53,[[["t"]],["t"]]],[11,"into","","",53,[[["self"]],["u"]]],[11,"try_from","","",53,[[["u"]],["result"]]],[11,"borrow","","",53,[[["self"]],["t"]]],[11,"borrow_mut","","",53,[[["self"]],["t"]]],[11,"try_into","","",53,[[["self"]],["result"]]],[11,"get_type_id","","",53,[[["self"]],["typeid"]]],[11,"from","","",52,[[["t"]],["t"]]],[11,"into","","",52,[[["self"]],["u"]]],[11,"try_from","","",52,[[["u"]],["result"]]],[11,"borrow","","",52,[[["self"]],["t"]]],[11,"borrow_mut","","",52,[[["self"]],["t"]]],[11,"try_into","","",52,[[["self"]],["result"]]],[11,"get_type_id","","",52,[[["self"]],["typeid"]]],[11,"from","argmin::solver::trustregion::cauchypoint","",54,[[["t"]],["t"]]],[11,"into","","",54,[[["self"]],["u"]]],[11,"try_from","","",54,[[["u"]],["result"]]],[11,"borrow","","",54,[[["self"]],["t"]]],[11,"borrow_mut","","",54,[[["self"]],["t"]]],[11,"try_into","","",54,[[["self"]],["result"]]],[11,"get_type_id","","",54,[[["self"]],["typeid"]]],[11,"from","argmin::solver::trustregion::dogleg","",55,[[["t"]],["t"]]],[11,"into","","",55,[[["self"]],["u"]]],[11,"try_from","","",55,[[["u"]],["result"]]],[11,"borrow","","",55,[[["self"]],["t"]]],[11,"borrow_mut","","",55,[[["self"]],["t"]]],[11,"try_into","","",55,[[["self"]],["result"]]],[11,"get_type_id","","",55,[[["self"]],["typeid"]]],[11,"from","argmin::solver::trustregion::steihaug","",56,[[["t"]],["t"]]],[11,"into","","",56,[[["self"]],["u"]]],[11,"try_from","","",56,[[["u"]],["result"]]],[11,"borrow","","",56,[[["self"]],["t"]]],[11,"borrow_mut","","",56,[[["self"]],["t"]]],[11,"try_into","","",56,[[["self"]],["result"]]],[11,"get_type_id","","",56,[[["self"]],["typeid"]]],[11,"from","argmin::solver::trustregion::trustregion_method","",57,[[["t"]],["t"]]],[11,"into","","",57,[[["self"]],["u"]]],[11,"try_from","","",57,[[["u"]],["result"]]],[11,"borrow","","",57,[[["self"]],["t"]]],[11,"borrow_mut","","",57,[[["self"]],["t"]]],[11,"try_into","","",57,[[["self"]],["result"]]],[11,"get_type_id","","",57,[[["self"]],["typeid"]]],[11,"fmt","argmin::prelude","",24,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",32,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",18,[[["self"],["formatter"]],["result",["error"]]]],[11,"clone","","",32,[[["self"]],["terminationreason"]]],[11,"clone","","",31,[[["self"]],["argminkv"]]],[11,"clone","","",59,[[["self"]],["nooperator"]]],[11,"clone","","",18,[[["self"]],["argminresult"]]],[11,"default","","",59,[[],["nooperator"]]],[11,"default","","",31,[[],["argminkv"]]],[11,"default","","",61,[[],["argminlogger"]]],[11,"default","","",64,[[],["argminwriter"]]],[11,"fmt","","",24,[[["self"],["formatter"]],["result",["error"]]]],[11,"eq","","",32,[[["self"],["terminationreason"]],["bool"]]],[11,"cause","","",24,[[["self"]],["option",["fail"]]]],[11,"backtrace","","",24,[[["self"]],["option",["backtrace"]]]],[11,"write","","",64,[[["self"],["t"]],["result",["error"]]]],[11,"write","","",65,[[["self"],["t"]],["result",["error"]]]],[11,"log_info","","Log general info",61,[[["self"],["str"],["argminkv"]],["result",["error"]]]],[11,"log_iter","","This should be used to log iteration data only (because…",61,[[["self"],["argminkv"]],["result",["error"]]]],[11,"log_info","","Log general info",63,[[["self"],["str"],["argminkv"]],["result",["error"]]]],[11,"log_iter","","This should be used to log iteration data only (because…",63,[[["self"],["argminkv"]],["result",["error"]]]],[11,"apply","","",59,N],[11,"gradient","","",59,N],[11,"hessian","","",59,N],[11,"modify","","",59,N],[11,"fmt","argmin::prelude::ctrlc","",27,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",26,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",26,[[["self"],["formatter"]],["result",["error"]]]],[11,"description","","",26,[[["self"]],["str"]]],[11,"cause","","",26,[[["self"]],["option",["error"]]]],[11,"from","","",26,[[["error"]],["error"]]],[11,"fmt","argmin::prelude","",62,[[["self"],["formatter"]],["result",["error"]]]],[11,"as_fail","","",62,[[["self"]],["fail"]]],[11,"fmt","","",62,[[["self"],["formatter"]],["result",["error"]]]],[11,"as_ref","","",62,[[["self"]],["fail"]]],[11,"from","","",62,[[["f"]],["error"]]],[11,"clone","argmin::prelude::finitediff","",1,[[["self"]],["perturbationvector"]]],[11,"default","","",1,[[],["perturbationvector"]]],[11,"eval","argmin::solver::linesearch::condition","",43,[[["self"],["f64"],["t"],["f64"],["t"],["t"],["f64"]],["bool"]]],[11,"requires_cur_grad","","",43,[[["self"]],["bool"]]],[11,"eval","","",44,[[["self"],["f64"],["t"],["f64"],["t"],["t"],["f64"]],["bool"]]],[11,"requires_cur_grad","","",44,[[["self"]],["bool"]]],[11,"eval","","",45,[[["self"],["f64"],["t"],["f64"],["t"],["t"],["f64"]],["bool"]]],[11,"requires_cur_grad","","",45,[[["self"]],["bool"]]],[11,"eval","","",46,[[["self"],["f64"],["t"],["f64"],["t"],["t"],["f64"]],["bool"]]],[11,"requires_cur_grad","","",46,[[["self"]],["bool"]]],[11,"default","argmin::solver::conjugategradient::beta","",35,[[],["fletcherreeves"]]],[11,"default","","",36,[[],["polakribiere"]]],[11,"default","","",37,[[],["polakribiereplus"]]],[11,"default","","",38,[[],["hestenesstiefel"]]],[11,"run","argmin::solver::conjugategradient::cg","Run the optimization algorithm",33,[[["self"]],["result",["argminresult","error"]]]],[11,"run_fast","","Run the essential parts of the optimization algorithm (no…",33,[[["self"]],["result",["argminresult","error"]]]],[11,"apply","","Applies the cost function or operator to a parameter…",33,N],[11,"gradient","","Computes the gradient at parameter `param`. Returns an…",33,N],[11,"hessian","","Computes the Hessian at parameter `param`. Returns an…",33,N],[11,"cur_param","","Returns the current parameter vector.",33,N],[11,"cur_grad","","Returns the most recently stored gradient.",33,N],[11,"cur_hessian","","Returns the most recently stored Hessian.",33,N],[11,"set_cur_param","","Sets the current parameter to `param`.",33,N],[11,"set_cur_grad","","Sets the current gradient to `grad`.",33,N],[11,"set_cur_hessian","","Sets the current Hessian to `hessian`.",33,N],[11,"set_best_param","","Sets the best parameter vector to `param`.",33,N],[11,"modify","","Modify the parameter vector by calling the `modify` method…",33,N],[11,"result","","Returns the result of the optimization.",33,[[["self"]],["argminresult"]]],[11,"set_max_iters","","Sets the maximum number of iterations to `iters`.",33,[[["self"],["u64"]]]],[11,"max_iters","","Returns the maximum number of iterations.",33,[[["self"]],["u64"]]],[11,"increment_iter","","Increments the iteration counter.",33,[[["self"]]]],[11,"cur_iter","","Returns the current number of iterations.",33,[[["self"]],["u64"]]],[11,"cur_cost","","Returns the most recently stored cost function value.",33,[[["self"]],["f64"]]],[11,"set_cur_cost","","Sets the current cost function value to `cost`",33,[[["self"],["f64"]]]],[11,"best_cost","","Returns the best cost function value obtained so far.",33,[[["self"]],["f64"]]],[11,"set_best_cost","","Sets the best cost function value.",33,[[["self"],["f64"]]]],[11,"set_target_cost","","Sets the target cost function value to `cost`. The…",33,[[["self"],["f64"]]]],[11,"increment_cost_func_count","","Increments the counter for the computations of the cost…",33,[[["self"]]]],[11,"increase_cost_func_count","","Increases the counter for the computations of the cost…",33,[[["self"],["u64"]]]],[11,"cost_func_count","","Returns the current value of the counter for the…",33,[[["self"]],["u64"]]],[11,"increment_grad_func_count","","Increments the counter for the computations of the…",33,[[["self"]]]],[11,"increase_grad_func_count","","Increases the counter for the computations of the gradient…",33,[[["self"],["u64"]]]],[11,"grad_func_count","","Returns the current value of the counter for the…",33,[[["self"]],["u64"]]],[11,"increment_hessian_func_count","","Increments the counter for the computations of the Hessian…",33,[[["self"]]]],[11,"increase_hessian_func_count","","Increases the counter for the computations of the Hessian…",33,[[["self"],["u64"]]]],[11,"hessian_func_count","","Returns the current value of the counter for the…",33,[[["self"]],["u64"]]],[11,"add_logger","","Attaches a logger which implements `ArgminLog` to the…",33,[[["self"],["box",["argminlog"]]]]],[11,"add_writer","","Attaches a writer which implements `ArgminWrite` to the…",33,[[["self"],["box",["argminwrite"]]]]],[11,"set_termination_reason","","Sets the `TerminationReason`",33,[[["self"],["terminationreason"]]]],[11,"terminate","","Checks whether any of the conditions to terminate is true…",33,[[["self"]],["terminationreason"]]],[11,"base_reset","","Resets the `base` field to it's initial conditions. This…",33,[[["self"]]]],[11,"run","argmin::solver::conjugategradient::nonlinear_cg","Run the optimization algorithm",34,[[["self"]],["result",["argminresult","error"]]]],[11,"run_fast","","Run the essential parts of the optimization algorithm (no…",34,[[["self"]],["result",["argminresult","error"]]]],[11,"apply","","Applies the cost function or operator to a parameter…",34,N],[11,"gradient","","Computes the gradient at parameter `param`. Returns an…",34,N],[11,"hessian","","Computes the Hessian at parameter `param`. Returns an…",34,N],[11,"cur_param","","Returns the current parameter vector.",34,N],[11,"cur_grad","","Returns the most recently stored gradient.",34,N],[11,"cur_hessian","","Returns the most recently stored Hessian.",34,N],[11,"set_cur_param","","Sets the current parameter to `param`.",34,N],[11,"set_cur_grad","","Sets the current gradient to `grad`.",34,N],[11,"set_cur_hessian","","Sets the current Hessian to `hessian`.",34,N],[11,"set_best_param","","Sets the best parameter vector to `param`.",34,N],[11,"modify","","Modify the parameter vector by calling the `modify` method…",34,N],[11,"result","","Returns the result of the optimization.",34,[[["self"]],["argminresult"]]],[11,"set_max_iters","","Sets the maximum number of iterations to `iters`.",34,[[["self"],["u64"]]]],[11,"max_iters","","Returns the maximum number of iterations.",34,[[["self"]],["u64"]]],[11,"increment_iter","","Increments the iteration counter.",34,[[["self"]]]],[11,"cur_iter","","Returns the current number of iterations.",34,[[["self"]],["u64"]]],[11,"cur_cost","","Returns the most recently stored cost function value.",34,[[["self"]],["f64"]]],[11,"set_cur_cost","","Sets the current cost function value to `cost`",34,[[["self"],["f64"]]]],[11,"best_cost","","Returns the best cost function value obtained so far.",34,[[["self"]],["f64"]]],[11,"set_best_cost","","Sets the best cost function value.",34,[[["self"],["f64"]]]],[11,"set_target_cost","","Sets the target cost function value to `cost`. The…",34,[[["self"],["f64"]]]],[11,"increment_cost_func_count","","Increments the counter for the computations of the cost…",34,[[["self"]]]],[11,"increase_cost_func_count","","Increases the counter for the computations of the cost…",34,[[["self"],["u64"]]]],[11,"cost_func_count","","Returns the current value of the counter for the…",34,[[["self"]],["u64"]]],[11,"increment_grad_func_count","","Increments the counter for the computations of the…",34,[[["self"]]]],[11,"increase_grad_func_count","","Increases the counter for the computations of the gradient…",34,[[["self"],["u64"]]]],[11,"grad_func_count","","Returns the current value of the counter for the…",34,[[["self"]],["u64"]]],[11,"increment_hessian_func_count","","Increments the counter for the computations of the Hessian…",34,[[["self"]]]],[11,"increase_hessian_func_count","","Increases the counter for the computations of the Hessian…",34,[[["self"],["u64"]]]],[11,"hessian_func_count","","Returns the current value of the counter for the…",34,[[["self"]],["u64"]]],[11,"add_logger","","Attaches a logger which implements `ArgminLog` to the…",34,[[["self"],["box",["argminlog"]]]]],[11,"add_writer","","Attaches a writer which implements `ArgminWrite` to the…",34,[[["self"],["box",["argminwrite"]]]]],[11,"set_termination_reason","","Sets the `TerminationReason`",34,[[["self"],["terminationreason"]]]],[11,"terminate","","Checks whether any of the conditions to terminate is true…",34,[[["self"]],["terminationreason"]]],[11,"base_reset","","Resets the `base` field to it's initial conditions. This…",34,[[["self"]]]],[11,"run","argmin::solver::gradientdescent::steepestdescent","Run the optimization algorithm",39,[[["self"]],["result",["argminresult","error"]]]],[11,"run_fast","","Run the essential parts of the optimization algorithm (no…",39,[[["self"]],["result",["argminresult","error"]]]],[11,"apply","","Applies the cost function or operator to a parameter…",39,N],[11,"gradient","","Computes the gradient at parameter `param`. Returns an…",39,N],[11,"hessian","","Computes the Hessian at parameter `param`. Returns an…",39,N],[11,"cur_param","","Returns the current parameter vector.",39,N],[11,"cur_grad","","Returns the most recently stored gradient.",39,N],[11,"cur_hessian","","Returns the most recently stored Hessian.",39,N],[11,"set_cur_param","","Sets the current parameter to `param`.",39,N],[11,"set_cur_grad","","Sets the current gradient to `grad`.",39,N],[11,"set_cur_hessian","","Sets the current Hessian to `hessian`.",39,N],[11,"set_best_param","","Sets the best parameter vector to `param`.",39,N],[11,"modify","","Modify the parameter vector by calling the `modify` method…",39,N],[11,"result","","Returns the result of the optimization.",39,[[["self"]],["argminresult"]]],[11,"set_max_iters","","Sets the maximum number of iterations to `iters`.",39,[[["self"],["u64"]]]],[11,"max_iters","","Returns the maximum number of iterations.",39,[[["self"]],["u64"]]],[11,"increment_iter","","Increments the iteration counter.",39,[[["self"]]]],[11,"cur_iter","","Returns the current number of iterations.",39,[[["self"]],["u64"]]],[11,"cur_cost","","Returns the most recently stored cost function value.",39,[[["self"]],["f64"]]],[11,"set_cur_cost","","Sets the current cost function value to `cost`",39,[[["self"],["f64"]]]],[11,"best_cost","","Returns the best cost function value obtained so far.",39,[[["self"]],["f64"]]],[11,"set_best_cost","","Sets the best cost function value.",39,[[["self"],["f64"]]]],[11,"set_target_cost","","Sets the target cost function value to `cost`. The…",39,[[["self"],["f64"]]]],[11,"increment_cost_func_count","","Increments the counter for the computations of the cost…",39,[[["self"]]]],[11,"increase_cost_func_count","","Increases the counter for the computations of the cost…",39,[[["self"],["u64"]]]],[11,"cost_func_count","","Returns the current value of the counter for the…",39,[[["self"]],["u64"]]],[11,"increment_grad_func_count","","Increments the counter for the computations of the…",39,[[["self"]]]],[11,"increase_grad_func_count","","Increases the counter for the computations of the gradient…",39,[[["self"],["u64"]]]],[11,"grad_func_count","","Returns the current value of the counter for the…",39,[[["self"]],["u64"]]],[11,"increment_hessian_func_count","","Increments the counter for the computations of the Hessian…",39,[[["self"]]]],[11,"increase_hessian_func_count","","Increases the counter for the computations of the Hessian…",39,[[["self"],["u64"]]]],[11,"hessian_func_count","","Returns the current value of the counter for the…",39,[[["self"]],["u64"]]],[11,"add_logger","","Attaches a logger which implements `ArgminLog` to the…",39,[[["self"],["box",["argminlog"]]]]],[11,"add_writer","","Attaches a writer which implements `ArgminWrite` to the…",39,[[["self"],["box",["argminwrite"]]]]],[11,"set_termination_reason","","Sets the `TerminationReason`",39,[[["self"],["terminationreason"]]]],[11,"terminate","","Checks whether any of the conditions to terminate is true…",39,[[["self"]],["terminationreason"]]],[11,"base_reset","","Resets the `base` field to it's initial conditions. This…",39,[[["self"]]]],[11,"run","argmin::solver::landweber","Run the optimization algorithm",40,[[["self"]],["result",["argminresult","error"]]]],[11,"run_fast","","Run the essential parts of the optimization algorithm (no…",40,[[["self"]],["result",["argminresult","error"]]]],[11,"apply","","Applies the cost function or operator to a parameter…",40,N],[11,"gradient","","Computes the gradient at parameter `param`. Returns an…",40,N],[11,"hessian","","Computes the Hessian at parameter `param`. Returns an…",40,N],[11,"cur_param","","Returns the current parameter vector.",40,N],[11,"cur_grad","","Returns the most recently stored gradient.",40,N],[11,"cur_hessian","","Returns the most recently stored Hessian.",40,N],[11,"set_cur_param","","Sets the current parameter to `param`.",40,N],[11,"set_cur_grad","","Sets the current gradient to `grad`.",40,N],[11,"set_cur_hessian","","Sets the current Hessian to `hessian`.",40,N],[11,"set_best_param","","Sets the best parameter vector to `param`.",40,N],[11,"modify","","Modify the parameter vector by calling the `modify` method…",40,N],[11,"result","","Returns the result of the optimization.",40,[[["self"]],["argminresult"]]],[11,"set_max_iters","","Sets the maximum number of iterations to `iters`.",40,[[["self"],["u64"]]]],[11,"max_iters","","Returns the maximum number of iterations.",40,[[["self"]],["u64"]]],[11,"increment_iter","","Increments the iteration counter.",40,[[["self"]]]],[11,"cur_iter","","Returns the current number of iterations.",40,[[["self"]],["u64"]]],[11,"cur_cost","","Returns the most recently stored cost function value.",40,[[["self"]],["f64"]]],[11,"set_cur_cost","","Sets the current cost function value to `cost`",40,[[["self"],["f64"]]]],[11,"best_cost","","Returns the best cost function value obtained so far.",40,[[["self"]],["f64"]]],[11,"set_best_cost","","Sets the best cost function value.",40,[[["self"],["f64"]]]],[11,"set_target_cost","","Sets the target cost function value to `cost`. The…",40,[[["self"],["f64"]]]],[11,"increment_cost_func_count","","Increments the counter for the computations of the cost…",40,[[["self"]]]],[11,"increase_cost_func_count","","Increases the counter for the computations of the cost…",40,[[["self"],["u64"]]]],[11,"cost_func_count","","Returns the current value of the counter for the…",40,[[["self"]],["u64"]]],[11,"increment_grad_func_count","","Increments the counter for the computations of the…",40,[[["self"]]]],[11,"increase_grad_func_count","","Increases the counter for the computations of the gradient…",40,[[["self"],["u64"]]]],[11,"grad_func_count","","Returns the current value of the counter for the…",40,[[["self"]],["u64"]]],[11,"increment_hessian_func_count","","Increments the counter for the computations of the Hessian…",40,[[["self"]]]],[11,"increase_hessian_func_count","","Increases the counter for the computations of the Hessian…",40,[[["self"],["u64"]]]],[11,"hessian_func_count","","Returns the current value of the counter for the…",40,[[["self"]],["u64"]]],[11,"add_logger","","Attaches a logger which implements `ArgminLog` to the…",40,[[["self"],["box",["argminlog"]]]]],[11,"add_writer","","Attaches a writer which implements `ArgminWrite` to the…",40,[[["self"],["box",["argminwrite"]]]]],[11,"set_termination_reason","","Sets the `TerminationReason`",40,[[["self"],["terminationreason"]]]],[11,"terminate","","Checks whether any of the conditions to terminate is true…",40,[[["self"]],["terminationreason"]]],[11,"base_reset","","Resets the `base` field to it's initial conditions. This…",40,[[["self"]]]],[11,"run","argmin::solver::linesearch::backtracking","Run the optimization algorithm",41,[[["self"]],["result",["argminresult","error"]]]],[11,"run_fast","","Run the essential parts of the optimization algorithm (no…",41,[[["self"]],["result",["argminresult","error"]]]],[11,"apply","","Applies the cost function or operator to a parameter…",41,N],[11,"gradient","","Computes the gradient at parameter `param`. Returns an…",41,N],[11,"hessian","","Computes the Hessian at parameter `param`. Returns an…",41,N],[11,"cur_param","","Returns the current parameter vector.",41,N],[11,"cur_grad","","Returns the most recently stored gradient.",41,N],[11,"cur_hessian","","Returns the most recently stored Hessian.",41,N],[11,"set_cur_param","","Sets the current parameter to `param`.",41,N],[11,"set_cur_grad","","Sets the current gradient to `grad`.",41,N],[11,"set_cur_hessian","","Sets the current Hessian to `hessian`.",41,N],[11,"set_best_param","","Sets the best parameter vector to `param`.",41,N],[11,"modify","","Modify the parameter vector by calling the `modify` method…",41,N],[11,"result","","Returns the result of the optimization.",41,[[["self"]],["argminresult"]]],[11,"set_max_iters","","Sets the maximum number of iterations to `iters`.",41,[[["self"],["u64"]]]],[11,"max_iters","","Returns the maximum number of iterations.",41,[[["self"]],["u64"]]],[11,"increment_iter","","Increments the iteration counter.",41,[[["self"]]]],[11,"cur_iter","","Returns the current number of iterations.",41,[[["self"]],["u64"]]],[11,"cur_cost","","Returns the most recently stored cost function value.",41,[[["self"]],["f64"]]],[11,"set_cur_cost","","Sets the current cost function value to `cost`",41,[[["self"],["f64"]]]],[11,"best_cost","","Returns the best cost function value obtained so far.",41,[[["self"]],["f64"]]],[11,"set_best_cost","","Sets the best cost function value.",41,[[["self"],["f64"]]]],[11,"set_target_cost","","Sets the target cost function value to `cost`. The…",41,[[["self"],["f64"]]]],[11,"increment_cost_func_count","","Increments the counter for the computations of the cost…",41,[[["self"]]]],[11,"increase_cost_func_count","","Increases the counter for the computations of the cost…",41,[[["self"],["u64"]]]],[11,"cost_func_count","","Returns the current value of the counter for the…",41,[[["self"]],["u64"]]],[11,"increment_grad_func_count","","Increments the counter for the computations of the…",41,[[["self"]]]],[11,"increase_grad_func_count","","Increases the counter for the computations of the gradient…",41,[[["self"],["u64"]]]],[11,"grad_func_count","","Returns the current value of the counter for the…",41,[[["self"]],["u64"]]],[11,"increment_hessian_func_count","","Increments the counter for the computations of the Hessian…",41,[[["self"]]]],[11,"increase_hessian_func_count","","Increases the counter for the computations of the Hessian…",41,[[["self"],["u64"]]]],[11,"hessian_func_count","","Returns the current value of the counter for the…",41,[[["self"]],["u64"]]],[11,"add_logger","","Attaches a logger which implements `ArgminLog` to the…",41,[[["self"],["box",["argminlog"]]]]],[11,"add_writer","","Attaches a writer which implements `ArgminWrite` to the…",41,[[["self"],["box",["argminwrite"]]]]],[11,"set_termination_reason","","Sets the `TerminationReason`",41,[[["self"],["terminationreason"]]]],[11,"terminate","","Checks whether any of the conditions to terminate is true…",41,[[["self"]],["terminationreason"]]],[11,"base_reset","","Resets the `base` field to it's initial conditions. This…",41,[[["self"]]]],[11,"run","argmin::solver::linesearch::hagerzhang","Run the optimization algorithm",47,[[["self"]],["result",["argminresult","error"]]]],[11,"run_fast","","Run the essential parts of the optimization algorithm (no…",47,[[["self"]],["result",["argminresult","error"]]]],[11,"apply","","Applies the cost function or operator to a parameter…",47,N],[11,"gradient","","Computes the gradient at parameter `param`. Returns an…",47,N],[11,"hessian","","Computes the Hessian at parameter `param`. Returns an…",47,N],[11,"cur_param","","Returns the current parameter vector.",47,N],[11,"cur_grad","","Returns the most recently stored gradient.",47,N],[11,"cur_hessian","","Returns the most recently stored Hessian.",47,N],[11,"set_cur_param","","Sets the current parameter to `param`.",47,N],[11,"set_cur_grad","","Sets the current gradient to `grad`.",47,N],[11,"set_cur_hessian","","Sets the current Hessian to `hessian`.",47,N],[11,"set_best_param","","Sets the best parameter vector to `param`.",47,N],[11,"modify","","Modify the parameter vector by calling the `modify` method…",47,N],[11,"result","","Returns the result of the optimization.",47,[[["self"]],["argminresult"]]],[11,"set_max_iters","","Sets the maximum number of iterations to `iters`.",47,[[["self"],["u64"]]]],[11,"max_iters","","Returns the maximum number of iterations.",47,[[["self"]],["u64"]]],[11,"increment_iter","","Increments the iteration counter.",47,[[["self"]]]],[11,"cur_iter","","Returns the current number of iterations.",47,[[["self"]],["u64"]]],[11,"cur_cost","","Returns the most recently stored cost function value.",47,[[["self"]],["f64"]]],[11,"set_cur_cost","","Sets the current cost function value to `cost`",47,[[["self"],["f64"]]]],[11,"best_cost","","Returns the best cost function value obtained so far.",47,[[["self"]],["f64"]]],[11,"set_best_cost","","Sets the best cost function value.",47,[[["self"],["f64"]]]],[11,"set_target_cost","","Sets the target cost function value to `cost`. The…",47,[[["self"],["f64"]]]],[11,"increment_cost_func_count","","Increments the counter for the computations of the cost…",47,[[["self"]]]],[11,"increase_cost_func_count","","Increases the counter for the computations of the cost…",47,[[["self"],["u64"]]]],[11,"cost_func_count","","Returns the current value of the counter for the…",47,[[["self"]],["u64"]]],[11,"increment_grad_func_count","","Increments the counter for the computations of the…",47,[[["self"]]]],[11,"increase_grad_func_count","","Increases the counter for the computations of the gradient…",47,[[["self"],["u64"]]]],[11,"grad_func_count","","Returns the current value of the counter for the…",47,[[["self"]],["u64"]]],[11,"increment_hessian_func_count","","Increments the counter for the computations of the Hessian…",47,[[["self"]]]],[11,"increase_hessian_func_count","","Increases the counter for the computations of the Hessian…",47,[[["self"],["u64"]]]],[11,"hessian_func_count","","Returns the current value of the counter for the…",47,[[["self"]],["u64"]]],[11,"add_logger","","Attaches a logger which implements `ArgminLog` to the…",47,[[["self"],["box",["argminlog"]]]]],[11,"add_writer","","Attaches a writer which implements `ArgminWrite` to the…",47,[[["self"],["box",["argminwrite"]]]]],[11,"set_termination_reason","","Sets the `TerminationReason`",47,[[["self"],["terminationreason"]]]],[11,"terminate","","Checks whether any of the conditions to terminate is true…",47,[[["self"]],["terminationreason"]]],[11,"base_reset","","Resets the `base` field to it's initial conditions. This…",47,[[["self"]]]],[11,"run","argmin::solver::linesearch::morethuente","Run the optimization algorithm",48,[[["self"]],["result",["argminresult","error"]]]],[11,"run_fast","","Run the essential parts of the optimization algorithm (no…",48,[[["self"]],["result",["argminresult","error"]]]],[11,"apply","","Applies the cost function or operator to a parameter…",48,N],[11,"gradient","","Computes the gradient at parameter `param`. Returns an…",48,N],[11,"hessian","","Computes the Hessian at parameter `param`. Returns an…",48,N],[11,"cur_param","","Returns the current parameter vector.",48,N],[11,"cur_grad","","Returns the most recently stored gradient.",48,N],[11,"cur_hessian","","Returns the most recently stored Hessian.",48,N],[11,"set_cur_param","","Sets the current parameter to `param`.",48,N],[11,"set_cur_grad","","Sets the current gradient to `grad`.",48,N],[11,"set_cur_hessian","","Sets the current Hessian to `hessian`.",48,N],[11,"set_best_param","","Sets the best parameter vector to `param`.",48,N],[11,"modify","","Modify the parameter vector by calling the `modify` method…",48,N],[11,"result","","Returns the result of the optimization.",48,[[["self"]],["argminresult"]]],[11,"set_max_iters","","Sets the maximum number of iterations to `iters`.",48,[[["self"],["u64"]]]],[11,"max_iters","","Returns the maximum number of iterations.",48,[[["self"]],["u64"]]],[11,"increment_iter","","Increments the iteration counter.",48,[[["self"]]]],[11,"cur_iter","","Returns the current number of iterations.",48,[[["self"]],["u64"]]],[11,"cur_cost","","Returns the most recently stored cost function value.",48,[[["self"]],["f64"]]],[11,"set_cur_cost","","Sets the current cost function value to `cost`",48,[[["self"],["f64"]]]],[11,"best_cost","","Returns the best cost function value obtained so far.",48,[[["self"]],["f64"]]],[11,"set_best_cost","","Sets the best cost function value.",48,[[["self"],["f64"]]]],[11,"set_target_cost","","Sets the target cost function value to `cost`. The…",48,[[["self"],["f64"]]]],[11,"increment_cost_func_count","","Increments the counter for the computations of the cost…",48,[[["self"]]]],[11,"increase_cost_func_count","","Increases the counter for the computations of the cost…",48,[[["self"],["u64"]]]],[11,"cost_func_count","","Returns the current value of the counter for the…",48,[[["self"]],["u64"]]],[11,"increment_grad_func_count","","Increments the counter for the computations of the…",48,[[["self"]]]],[11,"increase_grad_func_count","","Increases the counter for the computations of the gradient…",48,[[["self"],["u64"]]]],[11,"grad_func_count","","Returns the current value of the counter for the…",48,[[["self"]],["u64"]]],[11,"increment_hessian_func_count","","Increments the counter for the computations of the Hessian…",48,[[["self"]]]],[11,"increase_hessian_func_count","","Increases the counter for the computations of the Hessian…",48,[[["self"],["u64"]]]],[11,"hessian_func_count","","Returns the current value of the counter for the…",48,[[["self"]],["u64"]]],[11,"add_logger","","Attaches a logger which implements `ArgminLog` to the…",48,[[["self"],["box",["argminlog"]]]]],[11,"add_writer","","Attaches a writer which implements `ArgminWrite` to the…",48,[[["self"],["box",["argminwrite"]]]]],[11,"set_termination_reason","","Sets the `TerminationReason`",48,[[["self"],["terminationreason"]]]],[11,"terminate","","Checks whether any of the conditions to terminate is true…",48,[[["self"]],["terminationreason"]]],[11,"base_reset","","Resets the `base` field to it's initial conditions. This…",48,[[["self"]]]],[11,"run","argmin::solver::newton::newton_cg","Run the optimization algorithm",49,[[["self"]],["result",["argminresult","error"]]]],[11,"run_fast","","Run the essential parts of the optimization algorithm (no…",49,[[["self"]],["result",["argminresult","error"]]]],[11,"apply","","Applies the cost function or operator to a parameter…",49,N],[11,"gradient","","Computes the gradient at parameter `param`. Returns an…",49,N],[11,"hessian","","Computes the Hessian at parameter `param`. Returns an…",49,N],[11,"cur_param","","Returns the current parameter vector.",49,N],[11,"cur_grad","","Returns the most recently stored gradient.",49,N],[11,"cur_hessian","","Returns the most recently stored Hessian.",49,N],[11,"set_cur_param","","Sets the current parameter to `param`.",49,N],[11,"set_cur_grad","","Sets the current gradient to `grad`.",49,N],[11,"set_cur_hessian","","Sets the current Hessian to `hessian`.",49,N],[11,"set_best_param","","Sets the best parameter vector to `param`.",49,N],[11,"modify","","Modify the parameter vector by calling the `modify` method…",49,N],[11,"result","","Returns the result of the optimization.",49,[[["self"]],["argminresult"]]],[11,"set_max_iters","","Sets the maximum number of iterations to `iters`.",49,[[["self"],["u64"]]]],[11,"max_iters","","Returns the maximum number of iterations.",49,[[["self"]],["u64"]]],[11,"increment_iter","","Increments the iteration counter.",49,[[["self"]]]],[11,"cur_iter","","Returns the current number of iterations.",49,[[["self"]],["u64"]]],[11,"cur_cost","","Returns the most recently stored cost function value.",49,[[["self"]],["f64"]]],[11,"set_cur_cost","","Sets the current cost function value to `cost`",49,[[["self"],["f64"]]]],[11,"best_cost","","Returns the best cost function value obtained so far.",49,[[["self"]],["f64"]]],[11,"set_best_cost","","Sets the best cost function value.",49,[[["self"],["f64"]]]],[11,"set_target_cost","","Sets the target cost function value to `cost`. The…",49,[[["self"],["f64"]]]],[11,"increment_cost_func_count","","Increments the counter for the computations of the cost…",49,[[["self"]]]],[11,"increase_cost_func_count","","Increases the counter for the computations of the cost…",49,[[["self"],["u64"]]]],[11,"cost_func_count","","Returns the current value of the counter for the…",49,[[["self"]],["u64"]]],[11,"increment_grad_func_count","","Increments the counter for the computations of the…",49,[[["self"]]]],[11,"increase_grad_func_count","","Increases the counter for the computations of the gradient…",49,[[["self"],["u64"]]]],[11,"grad_func_count","","Returns the current value of the counter for the…",49,[[["self"]],["u64"]]],[11,"increment_hessian_func_count","","Increments the counter for the computations of the Hessian…",49,[[["self"]]]],[11,"increase_hessian_func_count","","Increases the counter for the computations of the Hessian…",49,[[["self"],["u64"]]]],[11,"hessian_func_count","","Returns the current value of the counter for the…",49,[[["self"]],["u64"]]],[11,"add_logger","","Attaches a logger which implements `ArgminLog` to the…",49,[[["self"],["box",["argminlog"]]]]],[11,"add_writer","","Attaches a writer which implements `ArgminWrite` to the…",49,[[["self"],["box",["argminwrite"]]]]],[11,"set_termination_reason","","Sets the `TerminationReason`",49,[[["self"],["terminationreason"]]]],[11,"terminate","","Checks whether any of the conditions to terminate is true…",49,[[["self"]],["terminationreason"]]],[11,"base_reset","","Resets the `base` field to it's initial conditions. This…",49,[[["self"]]]],[11,"run","argmin::solver::newton::newton_method","Run the optimization algorithm",50,[[["self"]],["result",["argminresult","error"]]]],[11,"run_fast","","Run the essential parts of the optimization algorithm (no…",50,[[["self"]],["result",["argminresult","error"]]]],[11,"apply","","Applies the cost function or operator to a parameter…",50,N],[11,"gradient","","Computes the gradient at parameter `param`. Returns an…",50,N],[11,"hessian","","Computes the Hessian at parameter `param`. Returns an…",50,N],[11,"cur_param","","Returns the current parameter vector.",50,N],[11,"cur_grad","","Returns the most recently stored gradient.",50,N],[11,"cur_hessian","","Returns the most recently stored Hessian.",50,N],[11,"set_cur_param","","Sets the current parameter to `param`.",50,N],[11,"set_cur_grad","","Sets the current gradient to `grad`.",50,N],[11,"set_cur_hessian","","Sets the current Hessian to `hessian`.",50,N],[11,"set_best_param","","Sets the best parameter vector to `param`.",50,N],[11,"modify","","Modify the parameter vector by calling the `modify` method…",50,N],[11,"result","","Returns the result of the optimization.",50,[[["self"]],["argminresult"]]],[11,"set_max_iters","","Sets the maximum number of iterations to `iters`.",50,[[["self"],["u64"]]]],[11,"max_iters","","Returns the maximum number of iterations.",50,[[["self"]],["u64"]]],[11,"increment_iter","","Increments the iteration counter.",50,[[["self"]]]],[11,"cur_iter","","Returns the current number of iterations.",50,[[["self"]],["u64"]]],[11,"cur_cost","","Returns the most recently stored cost function value.",50,[[["self"]],["f64"]]],[11,"set_cur_cost","","Sets the current cost function value to `cost`",50,[[["self"],["f64"]]]],[11,"best_cost","","Returns the best cost function value obtained so far.",50,[[["self"]],["f64"]]],[11,"set_best_cost","","Sets the best cost function value.",50,[[["self"],["f64"]]]],[11,"set_target_cost","","Sets the target cost function value to `cost`. The…",50,[[["self"],["f64"]]]],[11,"increment_cost_func_count","","Increments the counter for the computations of the cost…",50,[[["self"]]]],[11,"increase_cost_func_count","","Increases the counter for the computations of the cost…",50,[[["self"],["u64"]]]],[11,"cost_func_count","","Returns the current value of the counter for the…",50,[[["self"]],["u64"]]],[11,"increment_grad_func_count","","Increments the counter for the computations of the…",50,[[["self"]]]],[11,"increase_grad_func_count","","Increases the counter for the computations of the gradient…",50,[[["self"],["u64"]]]],[11,"grad_func_count","","Returns the current value of the counter for the…",50,[[["self"]],["u64"]]],[11,"increment_hessian_func_count","","Increments the counter for the computations of the Hessian…",50,[[["self"]]]],[11,"increase_hessian_func_count","","Increases the counter for the computations of the Hessian…",50,[[["self"],["u64"]]]],[11,"hessian_func_count","","Returns the current value of the counter for the…",50,[[["self"]],["u64"]]],[11,"add_logger","","Attaches a logger which implements `ArgminLog` to the…",50,[[["self"],["box",["argminlog"]]]]],[11,"add_writer","","Attaches a writer which implements `ArgminWrite` to the…",50,[[["self"],["box",["argminwrite"]]]]],[11,"set_termination_reason","","Sets the `TerminationReason`",50,[[["self"],["terminationreason"]]]],[11,"terminate","","Checks whether any of the conditions to terminate is true…",50,[[["self"]],["terminationreason"]]],[11,"base_reset","","Resets the `base` field to it's initial conditions. This…",50,[[["self"]]]],[11,"run","argmin::solver::quasinewton::bfgs","Run the optimization algorithm",51,[[["self"]],["result",["argminresult","error"]]]],[11,"run_fast","","Run the essential parts of the optimization algorithm (no…",51,[[["self"]],["result",["argminresult","error"]]]],[11,"apply","","Applies the cost function or operator to a parameter…",51,N],[11,"gradient","","Computes the gradient at parameter `param`. Returns an…",51,N],[11,"hessian","","Computes the Hessian at parameter `param`. Returns an…",51,N],[11,"cur_param","","Returns the current parameter vector.",51,N],[11,"cur_grad","","Returns the most recently stored gradient.",51,N],[11,"cur_hessian","","Returns the most recently stored Hessian.",51,N],[11,"set_cur_param","","Sets the current parameter to `param`.",51,N],[11,"set_cur_grad","","Sets the current gradient to `grad`.",51,N],[11,"set_cur_hessian","","Sets the current Hessian to `hessian`.",51,N],[11,"set_best_param","","Sets the best parameter vector to `param`.",51,N],[11,"modify","","Modify the parameter vector by calling the `modify` method…",51,N],[11,"result","","Returns the result of the optimization.",51,[[["self"]],["argminresult"]]],[11,"set_max_iters","","Sets the maximum number of iterations to `iters`.",51,[[["self"],["u64"]]]],[11,"max_iters","","Returns the maximum number of iterations.",51,[[["self"]],["u64"]]],[11,"increment_iter","","Increments the iteration counter.",51,[[["self"]]]],[11,"cur_iter","","Returns the current number of iterations.",51,[[["self"]],["u64"]]],[11,"cur_cost","","Returns the most recently stored cost function value.",51,[[["self"]],["f64"]]],[11,"set_cur_cost","","Sets the current cost function value to `cost`",51,[[["self"],["f64"]]]],[11,"best_cost","","Returns the best cost function value obtained so far.",51,[[["self"]],["f64"]]],[11,"set_best_cost","","Sets the best cost function value.",51,[[["self"],["f64"]]]],[11,"set_target_cost","","Sets the target cost function value to `cost`. The…",51,[[["self"],["f64"]]]],[11,"increment_cost_func_count","","Increments the counter for the computations of the cost…",51,[[["self"]]]],[11,"increase_cost_func_count","","Increases the counter for the computations of the cost…",51,[[["self"],["u64"]]]],[11,"cost_func_count","","Returns the current value of the counter for the…",51,[[["self"]],["u64"]]],[11,"increment_grad_func_count","","Increments the counter for the computations of the…",51,[[["self"]]]],[11,"increase_grad_func_count","","Increases the counter for the computations of the gradient…",51,[[["self"],["u64"]]]],[11,"grad_func_count","","Returns the current value of the counter for the…",51,[[["self"]],["u64"]]],[11,"increment_hessian_func_count","","Increments the counter for the computations of the Hessian…",51,[[["self"]]]],[11,"increase_hessian_func_count","","Increases the counter for the computations of the Hessian…",51,[[["self"],["u64"]]]],[11,"hessian_func_count","","Returns the current value of the counter for the…",51,[[["self"]],["u64"]]],[11,"add_logger","","Attaches a logger which implements `ArgminLog` to the…",51,[[["self"],["box",["argminlog"]]]]],[11,"add_writer","","Attaches a writer which implements `ArgminWrite` to the…",51,[[["self"],["box",["argminwrite"]]]]],[11,"set_termination_reason","","Sets the `TerminationReason`",51,[[["self"],["terminationreason"]]]],[11,"terminate","","Checks whether any of the conditions to terminate is true…",51,[[["self"]],["terminationreason"]]],[11,"base_reset","","Resets the `base` field to it's initial conditions. This…",51,[[["self"]]]],[11,"run","argmin::solver::simulatedannealing","Run the optimization algorithm",53,[[["self"]],["result",["argminresult","error"]]]],[11,"run_fast","","Run the essential parts of the optimization algorithm (no…",53,[[["self"]],["result",["argminresult","error"]]]],[11,"apply","","Applies the cost function or operator to a parameter…",53,N],[11,"gradient","","Computes the gradient at parameter `param`. Returns an…",53,N],[11,"hessian","","Computes the Hessian at parameter `param`. Returns an…",53,N],[11,"cur_param","","Returns the current parameter vector.",53,N],[11,"cur_grad","","Returns the most recently stored gradient.",53,N],[11,"cur_hessian","","Returns the most recently stored Hessian.",53,N],[11,"set_cur_param","","Sets the current parameter to `param`.",53,N],[11,"set_cur_grad","","Sets the current gradient to `grad`.",53,N],[11,"set_cur_hessian","","Sets the current Hessian to `hessian`.",53,N],[11,"set_best_param","","Sets the best parameter vector to `param`.",53,N],[11,"modify","","Modify the parameter vector by calling the `modify` method…",53,N],[11,"result","","Returns the result of the optimization.",53,[[["self"]],["argminresult"]]],[11,"set_max_iters","","Sets the maximum number of iterations to `iters`.",53,[[["self"],["u64"]]]],[11,"max_iters","","Returns the maximum number of iterations.",53,[[["self"]],["u64"]]],[11,"increment_iter","","Increments the iteration counter.",53,[[["self"]]]],[11,"cur_iter","","Returns the current number of iterations.",53,[[["self"]],["u64"]]],[11,"cur_cost","","Returns the most recently stored cost function value.",53,[[["self"]],["f64"]]],[11,"set_cur_cost","","Sets the current cost function value to `cost`",53,[[["self"],["f64"]]]],[11,"best_cost","","Returns the best cost function value obtained so far.",53,[[["self"]],["f64"]]],[11,"set_best_cost","","Sets the best cost function value.",53,[[["self"],["f64"]]]],[11,"set_target_cost","","Sets the target cost function value to `cost`. The…",53,[[["self"],["f64"]]]],[11,"increment_cost_func_count","","Increments the counter for the computations of the cost…",53,[[["self"]]]],[11,"increase_cost_func_count","","Increases the counter for the computations of the cost…",53,[[["self"],["u64"]]]],[11,"cost_func_count","","Returns the current value of the counter for the…",53,[[["self"]],["u64"]]],[11,"increment_grad_func_count","","Increments the counter for the computations of the…",53,[[["self"]]]],[11,"increase_grad_func_count","","Increases the counter for the computations of the gradient…",53,[[["self"],["u64"]]]],[11,"grad_func_count","","Returns the current value of the counter for the…",53,[[["self"]],["u64"]]],[11,"increment_hessian_func_count","","Increments the counter for the computations of the Hessian…",53,[[["self"]]]],[11,"increase_hessian_func_count","","Increases the counter for the computations of the Hessian…",53,[[["self"],["u64"]]]],[11,"hessian_func_count","","Returns the current value of the counter for the…",53,[[["self"]],["u64"]]],[11,"add_logger","","Attaches a logger which implements `ArgminLog` to the…",53,[[["self"],["box",["argminlog"]]]]],[11,"add_writer","","Attaches a writer which implements `ArgminWrite` to the…",53,[[["self"],["box",["argminwrite"]]]]],[11,"set_termination_reason","","Sets the `TerminationReason`",53,[[["self"],["terminationreason"]]]],[11,"terminate","","Checks whether any of the conditions to terminate is true…",53,[[["self"]],["terminationreason"]]],[11,"base_reset","","Resets the `base` field to it's initial conditions. This…",53,[[["self"]]]],[11,"run","argmin::solver::trustregion::cauchypoint","Run the optimization algorithm",54,[[["self"]],["result",["argminresult","error"]]]],[11,"run_fast","","Run the essential parts of the optimization algorithm (no…",54,[[["self"]],["result",["argminresult","error"]]]],[11,"apply","","Applies the cost function or operator to a parameter…",54,N],[11,"gradient","","Computes the gradient at parameter `param`. Returns an…",54,N],[11,"hessian","","Computes the Hessian at parameter `param`. Returns an…",54,N],[11,"cur_param","","Returns the current parameter vector.",54,N],[11,"cur_grad","","Returns the most recently stored gradient.",54,N],[11,"cur_hessian","","Returns the most recently stored Hessian.",54,N],[11,"set_cur_param","","Sets the current parameter to `param`.",54,N],[11,"set_cur_grad","","Sets the current gradient to `grad`.",54,N],[11,"set_cur_hessian","","Sets the current Hessian to `hessian`.",54,N],[11,"set_best_param","","Sets the best parameter vector to `param`.",54,N],[11,"modify","","Modify the parameter vector by calling the `modify` method…",54,N],[11,"result","","Returns the result of the optimization.",54,[[["self"]],["argminresult"]]],[11,"set_max_iters","","Sets the maximum number of iterations to `iters`.",54,[[["self"],["u64"]]]],[11,"max_iters","","Returns the maximum number of iterations.",54,[[["self"]],["u64"]]],[11,"increment_iter","","Increments the iteration counter.",54,[[["self"]]]],[11,"cur_iter","","Returns the current number of iterations.",54,[[["self"]],["u64"]]],[11,"cur_cost","","Returns the most recently stored cost function value.",54,[[["self"]],["f64"]]],[11,"set_cur_cost","","Sets the current cost function value to `cost`",54,[[["self"],["f64"]]]],[11,"best_cost","","Returns the best cost function value obtained so far.",54,[[["self"]],["f64"]]],[11,"set_best_cost","","Sets the best cost function value.",54,[[["self"],["f64"]]]],[11,"set_target_cost","","Sets the target cost function value to `cost`. The…",54,[[["self"],["f64"]]]],[11,"increment_cost_func_count","","Increments the counter for the computations of the cost…",54,[[["self"]]]],[11,"increase_cost_func_count","","Increases the counter for the computations of the cost…",54,[[["self"],["u64"]]]],[11,"cost_func_count","","Returns the current value of the counter for the…",54,[[["self"]],["u64"]]],[11,"increment_grad_func_count","","Increments the counter for the computations of the…",54,[[["self"]]]],[11,"increase_grad_func_count","","Increases the counter for the computations of the gradient…",54,[[["self"],["u64"]]]],[11,"grad_func_count","","Returns the current value of the counter for the…",54,[[["self"]],["u64"]]],[11,"increment_hessian_func_count","","Increments the counter for the computations of the Hessian…",54,[[["self"]]]],[11,"increase_hessian_func_count","","Increases the counter for the computations of the Hessian…",54,[[["self"],["u64"]]]],[11,"hessian_func_count","","Returns the current value of the counter for the…",54,[[["self"]],["u64"]]],[11,"add_logger","","Attaches a logger which implements `ArgminLog` to the…",54,[[["self"],["box",["argminlog"]]]]],[11,"add_writer","","Attaches a writer which implements `ArgminWrite` to the…",54,[[["self"],["box",["argminwrite"]]]]],[11,"set_termination_reason","","Sets the `TerminationReason`",54,[[["self"],["terminationreason"]]]],[11,"terminate","","Checks whether any of the conditions to terminate is true…",54,[[["self"]],["terminationreason"]]],[11,"base_reset","","Resets the `base` field to it's initial conditions. This…",54,[[["self"]]]],[11,"run","argmin::solver::trustregion::dogleg","Run the optimization algorithm",55,[[["self"]],["result",["argminresult","error"]]]],[11,"run_fast","","Run the essential parts of the optimization algorithm (no…",55,[[["self"]],["result",["argminresult","error"]]]],[11,"apply","","Applies the cost function or operator to a parameter…",55,N],[11,"gradient","","Computes the gradient at parameter `param`. Returns an…",55,N],[11,"hessian","","Computes the Hessian at parameter `param`. Returns an…",55,N],[11,"cur_param","","Returns the current parameter vector.",55,N],[11,"cur_grad","","Returns the most recently stored gradient.",55,N],[11,"cur_hessian","","Returns the most recently stored Hessian.",55,N],[11,"set_cur_param","","Sets the current parameter to `param`.",55,N],[11,"set_cur_grad","","Sets the current gradient to `grad`.",55,N],[11,"set_cur_hessian","","Sets the current Hessian to `hessian`.",55,N],[11,"set_best_param","","Sets the best parameter vector to `param`.",55,N],[11,"modify","","Modify the parameter vector by calling the `modify` method…",55,N],[11,"result","","Returns the result of the optimization.",55,[[["self"]],["argminresult"]]],[11,"set_max_iters","","Sets the maximum number of iterations to `iters`.",55,[[["self"],["u64"]]]],[11,"max_iters","","Returns the maximum number of iterations.",55,[[["self"]],["u64"]]],[11,"increment_iter","","Increments the iteration counter.",55,[[["self"]]]],[11,"cur_iter","","Returns the current number of iterations.",55,[[["self"]],["u64"]]],[11,"cur_cost","","Returns the most recently stored cost function value.",55,[[["self"]],["f64"]]],[11,"set_cur_cost","","Sets the current cost function value to `cost`",55,[[["self"],["f64"]]]],[11,"best_cost","","Returns the best cost function value obtained so far.",55,[[["self"]],["f64"]]],[11,"set_best_cost","","Sets the best cost function value.",55,[[["self"],["f64"]]]],[11,"set_target_cost","","Sets the target cost function value to `cost`. The…",55,[[["self"],["f64"]]]],[11,"increment_cost_func_count","","Increments the counter for the computations of the cost…",55,[[["self"]]]],[11,"increase_cost_func_count","","Increases the counter for the computations of the cost…",55,[[["self"],["u64"]]]],[11,"cost_func_count","","Returns the current value of the counter for the…",55,[[["self"]],["u64"]]],[11,"increment_grad_func_count","","Increments the counter for the computations of the…",55,[[["self"]]]],[11,"increase_grad_func_count","","Increases the counter for the computations of the gradient…",55,[[["self"],["u64"]]]],[11,"grad_func_count","","Returns the current value of the counter for the…",55,[[["self"]],["u64"]]],[11,"increment_hessian_func_count","","Increments the counter for the computations of the Hessian…",55,[[["self"]]]],[11,"increase_hessian_func_count","","Increases the counter for the computations of the Hessian…",55,[[["self"],["u64"]]]],[11,"hessian_func_count","","Returns the current value of the counter for the…",55,[[["self"]],["u64"]]],[11,"add_logger","","Attaches a logger which implements `ArgminLog` to the…",55,[[["self"],["box",["argminlog"]]]]],[11,"add_writer","","Attaches a writer which implements `ArgminWrite` to the…",55,[[["self"],["box",["argminwrite"]]]]],[11,"set_termination_reason","","Sets the `TerminationReason`",55,[[["self"],["terminationreason"]]]],[11,"terminate","","Checks whether any of the conditions to terminate is true…",55,[[["self"]],["terminationreason"]]],[11,"base_reset","","Resets the `base` field to it's initial conditions. This…",55,[[["self"]]]],[11,"run","argmin::solver::trustregion::steihaug","Run the optimization algorithm",56,[[["self"]],["result",["argminresult","error"]]]],[11,"run_fast","","Run the essential parts of the optimization algorithm (no…",56,[[["self"]],["result",["argminresult","error"]]]],[11,"apply","","Applies the cost function or operator to a parameter…",56,N],[11,"gradient","","Computes the gradient at parameter `param`. Returns an…",56,N],[11,"hessian","","Computes the Hessian at parameter `param`. Returns an…",56,N],[11,"cur_param","","Returns the current parameter vector.",56,N],[11,"cur_grad","","Returns the most recently stored gradient.",56,N],[11,"cur_hessian","","Returns the most recently stored Hessian.",56,N],[11,"set_cur_param","","Sets the current parameter to `param`.",56,N],[11,"set_cur_grad","","Sets the current gradient to `grad`.",56,N],[11,"set_cur_hessian","","Sets the current Hessian to `hessian`.",56,N],[11,"set_best_param","","Sets the best parameter vector to `param`.",56,N],[11,"modify","","Modify the parameter vector by calling the `modify` method…",56,N],[11,"result","","Returns the result of the optimization.",56,[[["self"]],["argminresult"]]],[11,"set_max_iters","","Sets the maximum number of iterations to `iters`.",56,[[["self"],["u64"]]]],[11,"max_iters","","Returns the maximum number of iterations.",56,[[["self"]],["u64"]]],[11,"increment_iter","","Increments the iteration counter.",56,[[["self"]]]],[11,"cur_iter","","Returns the current number of iterations.",56,[[["self"]],["u64"]]],[11,"cur_cost","","Returns the most recently stored cost function value.",56,[[["self"]],["f64"]]],[11,"set_cur_cost","","Sets the current cost function value to `cost`",56,[[["self"],["f64"]]]],[11,"best_cost","","Returns the best cost function value obtained so far.",56,[[["self"]],["f64"]]],[11,"set_best_cost","","Sets the best cost function value.",56,[[["self"],["f64"]]]],[11,"set_target_cost","","Sets the target cost function value to `cost`. The…",56,[[["self"],["f64"]]]],[11,"increment_cost_func_count","","Increments the counter for the computations of the cost…",56,[[["self"]]]],[11,"increase_cost_func_count","","Increases the counter for the computations of the cost…",56,[[["self"],["u64"]]]],[11,"cost_func_count","","Returns the current value of the counter for the…",56,[[["self"]],["u64"]]],[11,"increment_grad_func_count","","Increments the counter for the computations of the…",56,[[["self"]]]],[11,"increase_grad_func_count","","Increases the counter for the computations of the gradient…",56,[[["self"],["u64"]]]],[11,"grad_func_count","","Returns the current value of the counter for the…",56,[[["self"]],["u64"]]],[11,"increment_hessian_func_count","","Increments the counter for the computations of the Hessian…",56,[[["self"]]]],[11,"increase_hessian_func_count","","Increases the counter for the computations of the Hessian…",56,[[["self"],["u64"]]]],[11,"hessian_func_count","","Returns the current value of the counter for the…",56,[[["self"]],["u64"]]],[11,"add_logger","","Attaches a logger which implements `ArgminLog` to the…",56,[[["self"],["box",["argminlog"]]]]],[11,"add_writer","","Attaches a writer which implements `ArgminWrite` to the…",56,[[["self"],["box",["argminwrite"]]]]],[11,"set_termination_reason","","Sets the `TerminationReason`",56,[[["self"],["terminationreason"]]]],[11,"terminate","","Checks whether any of the conditions to terminate is true…",56,[[["self"]],["terminationreason"]]],[11,"base_reset","","Resets the `base` field to it's initial conditions. This…",56,[[["self"]]]],[11,"run","argmin::solver::trustregion::trustregion_method","Run the optimization algorithm",57,[[["self"]],["result",["argminresult","error"]]]],[11,"run_fast","","Run the essential parts of the optimization algorithm (no…",57,[[["self"]],["result",["argminresult","error"]]]],[11,"apply","","Applies the cost function or operator to a parameter…",57,N],[11,"gradient","","Computes the gradient at parameter `param`. Returns an…",57,N],[11,"hessian","","Computes the Hessian at parameter `param`. Returns an…",57,N],[11,"cur_param","","Returns the current parameter vector.",57,N],[11,"cur_grad","","Returns the most recently stored gradient.",57,N],[11,"cur_hessian","","Returns the most recently stored Hessian.",57,N],[11,"set_cur_param","","Sets the current parameter to `param`.",57,N],[11,"set_cur_grad","","Sets the current gradient to `grad`.",57,N],[11,"set_cur_hessian","","Sets the current Hessian to `hessian`.",57,N],[11,"set_best_param","","Sets the best parameter vector to `param`.",57,N],[11,"modify","","Modify the parameter vector by calling the `modify` method…",57,N],[11,"result","","Returns the result of the optimization.",57,[[["self"]],["argminresult"]]],[11,"set_max_iters","","Sets the maximum number of iterations to `iters`.",57,[[["self"],["u64"]]]],[11,"max_iters","","Returns the maximum number of iterations.",57,[[["self"]],["u64"]]],[11,"increment_iter","","Increments the iteration counter.",57,[[["self"]]]],[11,"cur_iter","","Returns the current number of iterations.",57,[[["self"]],["u64"]]],[11,"cur_cost","","Returns the most recently stored cost function value.",57,[[["self"]],["f64"]]],[11,"set_cur_cost","","Sets the current cost function value to `cost`",57,[[["self"],["f64"]]]],[11,"best_cost","","Returns the best cost function value obtained so far.",57,[[["self"]],["f64"]]],[11,"set_best_cost","","Sets the best cost function value.",57,[[["self"],["f64"]]]],[11,"set_target_cost","","Sets the target cost function value to `cost`. The…",57,[[["self"],["f64"]]]],[11,"increment_cost_func_count","","Increments the counter for the computations of the cost…",57,[[["self"]]]],[11,"increase_cost_func_count","","Increases the counter for the computations of the cost…",57,[[["self"],["u64"]]]],[11,"cost_func_count","","Returns the current value of the counter for the…",57,[[["self"]],["u64"]]],[11,"increment_grad_func_count","","Increments the counter for the computations of the…",57,[[["self"]]]],[11,"increase_grad_func_count","","Increases the counter for the computations of the gradient…",57,[[["self"],["u64"]]]],[11,"grad_func_count","","Returns the current value of the counter for the…",57,[[["self"]],["u64"]]],[11,"increment_hessian_func_count","","Increments the counter for the computations of the Hessian…",57,[[["self"]]]],[11,"increase_hessian_func_count","","Increases the counter for the computations of the Hessian…",57,[[["self"],["u64"]]]],[11,"hessian_func_count","","Returns the current value of the counter for the…",57,[[["self"]],["u64"]]],[11,"add_logger","","Attaches a logger which implements `ArgminLog` to the…",57,[[["self"],["box",["argminlog"]]]]],[11,"add_writer","","Attaches a writer which implements `ArgminWrite` to the…",57,[[["self"],["box",["argminwrite"]]]]],[11,"set_termination_reason","","Sets the `TerminationReason`",57,[[["self"],["terminationreason"]]]],[11,"terminate","","Checks whether any of the conditions to terminate is true…",57,[[["self"]],["terminationreason"]]],[11,"base_reset","","Resets the `base` field to it's initial conditions. This…",57,[[["self"]]]],[11,"init","argmin::solver::conjugategradient::cg","",33,[[["self"]],["result",["error"]]]],[11,"next_iter","","Perform one iteration of SA algorithm",33,[[["self"]],["result",["argminiterationdata","error"]]]],[11,"init","argmin::solver::conjugategradient::nonlinear_cg","",34,[[["self"]],["result",["error"]]]],[11,"next_iter","","Perform one iteration of SA algorithm",34,[[["self"]],["result",["argminiterationdata","error"]]]],[11,"next_iter","argmin::solver::gradientdescent::steepestdescent","Perform one iteration of SA algorithm",39,[[["self"]],["result",["argminiterationdata","error"]]]],[11,"next_iter","argmin::solver::landweber","",40,[[["self"]],["result",["argminiterationdata","error"]]]],[11,"next_iter","argmin::solver::linesearch::backtracking","",41,[[["self"]],["result",["argminiterationdata","error"]]]],[11,"init","argmin::solver::linesearch::hagerzhang","",47,[[["self"]],["result",["error"]]]],[11,"next_iter","","",47,[[["self"]],["result",["argminiterationdata","error"]]]],[11,"init","argmin::solver::linesearch::morethuente","",48,[[["self"]],["result",["error"]]]],[11,"next_iter","","",48,[[["self"]],["result",["argminiterationdata","error"]]]],[11,"next_iter","argmin::solver::newton::newton_cg","",49,[[["self"]],["result",["argminiterationdata","error"]]]],[11,"next_iter","argmin::solver::newton::newton_method","",50,[[["self"]],["result",["argminiterationdata","error"]]]],[11,"init","argmin::solver::quasinewton::bfgs","",51,[[["self"]],["result",["error"]]]],[11,"next_iter","","",51,[[["self"]],["result",["argminiterationdata","error"]]]],[11,"next_iter","argmin::solver::simulatedannealing","Perform one iteration of SA algorithm",53,[[["self"]],["result",["argminiterationdata","error"]]]],[11,"init","argmin::solver::trustregion::cauchypoint","",54,[[["self"]],["result",["error"]]]],[11,"next_iter","","",54,[[["self"]],["result",["argminiterationdata","error"]]]],[11,"init","argmin::solver::trustregion::dogleg","",55,[[["self"]],["result",["error"]]]],[11,"next_iter","","",55,[[["self"]],["result",["argminiterationdata","error"]]]],[11,"init","argmin::solver::trustregion::steihaug","",56,[[["self"]],["result",["error"]]]],[11,"next_iter","","",56,[[["self"]],["result",["argminiterationdata","error"]]]],[11,"init","argmin::solver::trustregion::trustregion_method","",57,[[["self"]],["result",["error"]]]],[11,"next_iter","","",57,[[["self"]],["result",["argminiterationdata","error"]]]],[11,"set_search_direction","argmin::solver::linesearch::backtracking","Set search direction",41,[[["self"],["t"]]]],[11,"set_initial_parameter","","Set initial parameter",41,[[["self"],["t"]]]],[11,"set_initial_alpha","","Set initial alpha value",41,[[["self"],["f64"]],["result",["error"]]]],[11,"set_initial_cost","","Set initial cost function value",41,[[["self"],["f64"]]]],[11,"set_initial_gradient","","Set initial gradient",41,[[["self"],["t"]]]],[11,"calc_initial_cost","","Calculate initial cost function value",41,[[["self"]],["result",["error"]]]],[11,"calc_initial_gradient","","Calculate initial cost function value",41,[[["self"]],["result",["error"]]]],[11,"set_search_direction","argmin::solver::linesearch::hagerzhang","Set search direction",47,[[["self"],["t"]]]],[11,"set_initial_parameter","","Set initial parameter",47,[[["self"],["t"]]]],[11,"set_initial_cost","","Set initial cost function value",47,[[["self"],["f64"]]]],[11,"set_initial_gradient","","Set initial gradient",47,[[["self"],["t"]]]],[11,"calc_initial_cost","","Calculate initial cost function value",47,[[["self"]],["result",["error"]]]],[11,"calc_initial_gradient","","Calculate initial cost function value",47,[[["self"]],["result",["error"]]]],[11,"set_initial_alpha","","Set initial alpha value",47,[[["self"],["f64"]],["result",["error"]]]],[11,"set_search_direction","argmin::solver::linesearch::morethuente","Set search direction",48,[[["self"],["t"]]]],[11,"set_initial_parameter","","Set initial parameter",48,[[["self"],["t"]]]],[11,"set_initial_cost","","Set initial cost function value",48,[[["self"],["f64"]]]],[11,"set_initial_gradient","","Set initial gradient",48,[[["self"],["t"]]]],[11,"calc_initial_cost","","Calculate initial cost function value",48,[[["self"]],["result",["error"]]]],[11,"calc_initial_gradient","","Calculate initial cost function value",48,[[["self"]],["result",["error"]]]],[11,"set_initial_alpha","","Set initial alpha value",48,[[["self"],["f64"]],["result",["error"]]]],[11,"set_radius","argmin::solver::trustregion::cauchypoint","",54,[[["self"],["f64"]]]],[11,"set_grad","","",54,[[["self"],["t"]]]],[11,"set_hessian","","",54,[[["self"],["h"]]]],[11,"set_radius","argmin::solver::trustregion::dogleg","",55,[[["self"],["f64"]]]],[11,"set_grad","","",55,[[["self"],["t"]]]],[11,"set_hessian","","",55,[[["self"],["h"]]]],[11,"set_radius","argmin::solver::trustregion::steihaug","",56,[[["self"],["f64"]]]],[11,"set_grad","","",56,[[["self"],["t"]]]],[11,"set_hessian","","",56,[[["self"],["h"]]]],[11,"update","argmin::solver::conjugategradient::beta","",35,[[["self"],["t"],["t"],["t"]],["f64"]]],[11,"update","","",36,[[["self"],["t"],["t"],["t"]],["f64"]]],[11,"update","","",37,[[["self"],["t"],["t"],["t"]],["f64"]]],[11,"update","","",38,[[["self"],["t"],["t"],["t"]],["f64"]]],[11,"new","argmin::prelude::finitediff","Create a new empty `PerturbationVector`",1,[[],["perturbationvector"]]],[11,"add","","Add an index `x_idx` and the corresponding function…",1,[[["self"],["usize"],["vec",["usize"]]],["perturbationvector"]]],[11,"new","argmin::prelude","Constructor",58,[[["t"],["f64"]],["argminiterationdata"]]],[11,"param","","Returns the parameter vector",58,[[["self"]],["t"]]],[11,"cost","","Returns the cost function value",58,[[["self"]],["f64"]]],[11,"add_kv","","Adds an `ArgminKV`",58,[[["self"],["argminkv"]],["argminiterationdata"]]],[11,"get_kv","","Returns an `ArgminKV`",58,[[["self"]],["option",["argminkv"]]]],[11,"new","","",59,[[],["nooperator"]]],[11,"new","","Constructor",60,[[["argminoperator"],["t"]],["argminbase"]]],[11,"kv_for_logs","","Return the KV for the initial logging",60,[[["self"]],["argminkv"]]],[11,"kv_for_iter","","Return the KV for logging of the iterations",60,[[["self"]],["argminkv"]]],[11,"reset","","Reset `self` to its initial state.",60,N],[11,"apply","","Apply the operator to `param`",60,[[["self"],["t"]],["result",["error"]]]],[11,"gradient","","Compute the gradient at `param`",60,[[["self"],["t"]],["result",["error"]]]],[11,"hessian","","Compute the hessian at `param`",60,[[["self"],["t"]],["result",["error"]]]],[11,"modify","","Modify a `param` with the `modify` method of `operator`.",60,[[["self"],["t"],["f64"]],["result",["error"]]]],[11,"set_cur_param","","Set the current parameter vector",60,[[["self"],["t"]],["argminbase"]]],[11,"cur_param","","Return the current parameter vector",60,[[["self"]],["t"]]],[11,"set_best_param","","Set the new best parameter vector",60,[[["self"],["t"]],["argminbase"]]],[11,"best_param","","Return the current best parameter vector",60,[[["self"]],["t"]]],[11,"set_cur_cost","","Set the current cost function value",60,[[["self"],["f64"]],["argminbase"]]],[11,"cur_cost","","Return the current cost function value",60,[[["self"]],["f64"]]],[11,"set_best_cost","","Set the cost function value of the current best parameter…",60,[[["self"],["f64"]],["argminbase"]]],[11,"best_cost","","Return the cost function value of the current best…",60,[[["self"]],["f64"]]],[11,"set_cur_grad","","Set the current gradient",60,[[["self"],["t"]],["argminbase"]]],[11,"cur_grad","","Return the current gradient",60,[[["self"]],["t"]]],[11,"set_cur_hessian","","Set the current hessian",60,[[["self"],["h"]],["argminbase"]]],[11,"cur_hessian","","Return the current hessian",60,[[["self"]],["h"]]],[11,"set_target_cost","","Set the target cost function value",60,[[["self"],["f64"]],["argminbase"]]],[11,"target_cost","","Return the target cost function value",60,[[["self"]],["f64"]]],[11,"increment_iter","","Increment the number of iterations.",60,[[["self"]],["argminbase"]]],[11,"cur_iter","","Return the current number of iterations",60,[[["self"]],["u64"]]],[11,"increment_cost_func_count","","Increment the cost function evaluation count",60,[[["self"]],["argminbase"]]],[11,"increase_cost_func_count","","Increaese the cost function evaluation count by a given…",60,[[["self"],["u64"]],["argminbase"]]],[11,"cost_func_count","","Return the cost function evaluation count",60,[[["self"]],["u64"]]],[11,"increment_grad_func_count","","Increment the gradient evaluation count",60,[[["self"]],["argminbase"]]],[11,"increase_grad_func_count","","Increase the gradient evaluation count by a given value",60,[[["self"],["u64"]],["argminbase"]]],[11,"grad_func_count","","Return the gradient evaluation count",60,[[["self"]],["u64"]]],[11,"increment_hessian_func_count","","Increment the hessian evaluation count",60,[[["self"]],["argminbase"]]],[11,"increase_hessian_func_count","","Increase the hessian evaluation count by a given value",60,[[["self"],["u64"]],["argminbase"]]],[11,"hessian_func_count","","Return the gradient evaluation count",60,[[["self"]],["u64"]]],[11,"set_max_iters","","Set the maximum number of iterations.",60,[[["self"],["u64"]],["argminbase"]]],[11,"max_iters","","Return the maximum number of iterations",60,[[["self"]],["u64"]]],[11,"set_termination_reason","","Set the `TerminationReason`",60,[[["self"],["terminationreason"]],["argminbase"]]],[11,"termination_reason","","Return the `TerminationReason`",60,[[["self"]],["terminationreason"]]],[11,"termination_reason_text","","Return the textual representation of the `TerminationReason`",60,[[["self"]],["str"]]],[11,"terminated","","Return whether the algorithm has terminated or not",60,[[["self"]],["bool"]]],[11,"result","","Return the result.",60,[[["self"]],["argminresult"]]],[11,"set_total_time","","Set the total time needed by the solver",60,[[["self"],["duration"]],["argminbase"]]],[11,"total_time","","Return the total time",60,[[["self"]],["duration"]]],[11,"add_logger","","Add a logger to the list of loggers",60,[[["self"],["box",["argminlog"]]],["argminbase"]]],[11,"add_writer","","Add a writer to the list of writers",60,[[["self"],["box",["argminwrite"]]],["argminbase"]]],[11,"log_iter","","Log a `kv`",60,[[["self"],["argminkv"]],["result",["error"]]]],[11,"log_info","","Log a message and a `kv`",60,[[["self"],["str"],["argminkv"]],["result",["error"]]]],[11,"write","","Write (TODO)",60,[[["self"],["t"]],["result",["error"]]]],[11,"new","","Constructor",61,[[],["argminlogger"]]],[11,"push","","Push another `ArgminLog` to the `logger` field",61,[[["self"],["box",["argminlog"]]],["argminlogger"]]],[11,"from_boxed_compat","","Creates an `Error` from `Box<std::error::Error>`.",62,[[["box",["error"]]],["error"]]],[11,"as_fail","","Return a reference to the underlying failure that this…",62,[[["self"]],["fail"]]],[11,"cause","","Returns a reference to the underlying cause of this…",62,[[["self"]],["fail"]]],[11,"backtrace","","Gets a reference to the `Backtrace` for this `Error`.",62,[[["self"]],["backtrace"]]],[11,"context","","Provides context for this `Error`.",62,[[["self"],["d"]],["context"]]],[11,"compat","","Wraps `Error` in a compatibility type.",62,[[["self"]],["compat",["error"]]]],[11,"downcast","","Attempts to downcast this `Error` to a particular `Fail`…",62,[[["self"]],["result",["error"]]]],[11,"find_root_cause","","Returns the \"root cause\" of this error - the last value in…",62,[[["self"]],["fail"]]],[11,"iter_causes","","Returns a iterator over the causes of this error with the…",62,[[["self"]],["causes"]]],[11,"iter_chain","","Returns a iterator over all fails up the chain from the…",62,[[["self"]],["causes"]]],[11,"downcast_ref","","Attempts to downcast this `Error` to a particular `Fail`…",62,[[["self"]],["option"]]],[11,"downcast_mut","","Attempts to downcast this `Error` to a particular `Fail`…",62,[[["self"]],["option"]]],[11,"root_cause","","Deprecated alias to `find_root_cause`.",62,[[["self"]],["fail"]]],[11,"causes","","Deprecated alias to `iter_causes`.",62,[[["self"]],["causes"]]],[11,"new","","Constructor",18,[[["t"],["f64"],["u64"],["terminationreason"]],["argminresult"]]],[11,"new","argmin::prelude::modcholesky","",22,[[["l"],["e"],["p"]],["decomposition"]]],[11,"term","argmin::prelude","Log to the terminal in a blocking way",63,[[],["box",["argminsloglogger"]]]],[11,"term_noblock","","Log to the terminal in a non-blocking way (in case of…",63,[[],["box",["argminsloglogger"]]]],[11,"file","","Log JSON to a file in a blocking way",63,[[["str"]],["result",["box","error"]]]],[11,"file_noblock","","Log JSON to a file in a non-blocking way (in case of…",63,[[["str"]],["result",["box","error"]]]],[11,"new","","",64,[[],["argminwriter"]]],[11,"push","","",64,[[["self"],["box",["argminwrite"]]],["argminwriter"]]],[11,"new","","",65,[[],["box",["writetofile"]]]],[11,"new","","Constructor",31,[[],["argminkv"]]],[11,"push","","Push a key-value pair to the `kv` vector.",31,[[["self"],["str"],["t"]],["argminkv"]]],[11,"merge","","Merge another `kv` into `self.kv`",31,[[["self"],["argminkv"]],["argminkv"]]],[11,"terminated","","Returns `true` if a solver terminated and `false` otherwise",32,[[["self"]],["bool"]]],[11,"text","","Returns a texual representation of what happened",32,[[["self"]],["str"]]]],"paths":[[8,"FiniteDiff"],[3,"PerturbationVector"],[8,"ArgminSolver"],[8,"ArgminNextIter"],[8,"ArgminLog"],[8,"ArgminWrite"],[8,"ArgminOperator"],[8,"ArgminLineSearch"],[8,"ArgminTrustRegion"],[8,"ArgminNLCGBetaUpdate"],[8,"ArgminScale"],[8,"ArgminScaledSub"],[8,"ArgminZero"],[8,"ArgminAdd"],[8,"ArgminDot"],[8,"ArgminWeightedDot"],[8,"ArgminEye"],[8,"ArgminMul"],[3,"ArgminResult"],[8,"GershgorinCircles"],[8,"ModCholeskySE90"],[8,"ModCholeskyGMW81"],[3,"Decomposition"],[8,"ModCholeskySE99"],[4,"ArgminError"],[8,"ArgminSub"],[4,"Error"],[4,"SignalType"],[8,"ArgminNorm"],[8,"ArgminScaledAdd"],[8,"ArgminInv"],[3,"ArgminKV"],[4,"TerminationReason"],[3,"ConjugateGradient"],[3,"NonlinearConjugateGradient"],[3,"FletcherReeves"],[3,"PolakRibiere"],[3,"PolakRibierePlus"],[3,"HestenesStiefel"],[3,"SteepestDescent"],[3,"Landweber"],[3,"BacktrackingLineSearch"],[8,"LineSearchCondition"],[3,"ArmijoCondition"],[3,"WolfeCondition"],[3,"StrongWolfeCondition"],[3,"GoldsteinCondition"],[3,"HagerZhangLineSearch"],[3,"MoreThuenteLineSearch"],[3,"NewtonCG"],[3,"Newton"],[3,"BFGS"],[4,"SATempFunc"],[3,"SimulatedAnnealing"],[3,"CauchyPoint"],[3,"Dogleg"],[3,"Steihaug"],[3,"TrustRegion"],[3,"ArgminIterationData"],[3,"NoOperator"],[3,"ArgminBase"],[3,"ArgminLogger"],[3,"Error"],[3,"ArgminSlogLogger"],[3,"ArgminWriter"],[3,"WriteToFile"]]};
initSearch(searchIndex);addSearchOptions(searchIndex);
